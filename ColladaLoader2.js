// Generated by CoffeeScript 1.6.2
/*
# ==============================================================================
# COLLADA file loader for three.js
#
# [1] https://github.com/mrdoob/three.js/
# [2] http://www.khronos.org/files/collada_spec_1_4.pdf
# [3] http://www.khronos.org/files/collada_spec_1_5.pdf
#
# Limitations by design:
# - Non-triangle primitives are not supported
# - Loading of geometry data from other documents is not supported
# ==============================================================================
*/

/**
*   @constructor
*   @struct
*/

var ColladaLoader2 = function() {this._init()};
/**
*   Indents a string
*
*   @param {!number} count
*   @param {!string} str
*   @return {!string}
*   @private
*/
ColladaLoader2.indentString = function(count, str) {
  var i, output, _i;

  output = "";
  for (i = _i = 1; _i <= count; i = _i += 1) {
    output += "    ";
  }
  output += str;
  return output;
};

/**
*   Returns one line of an ascii-art tree visualization
*
*   @param {!number} indent
*   @param {!string} str
*   @return {!string}
*   @private
*/


ColladaLoader2.graphNodeString = function(indent, str) {
  return ColladaLoader2.indentString(indent, "|-" + str);
};

/**
*   Returns one line of an ascii-art tree visualization
* 
*   @param {string|number|boolean|Object|null} node
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*   @private
*/


ColladaLoader2.getNodeInfo = function(node, indent, prefix) {
  if (node == null) {
    return "";
  }
  if (typeof node === "string") {
    return ColladaLoader2.graphNodeString(indent, prefix + ("'" + node + "'\n"));
  }
  if (typeof node === "number") {
    return ColladaLoader2.graphNodeString(indent, prefix + ("" + node + "\n"));
  }
  if (typeof node === "boolean") {
    return ColladaLoader2.graphNodeString(indent, prefix + ("" + node + "\n"));
  }
  if (node.getInfo != null) {
    return node.getInfo(indent, prefix);
  }
  return ColladaLoader2.graphNodeString(indent, prefix + "<unknown data type>\n");
};

/** @interface
*/


ColladaLoader2.FxTarget = function() {};

/** @type {?string}
*/


ColladaLoader2.FxTarget.prototype.sid;

/** @type {?ColladaLoader2.FxScope}
*/


ColladaLoader2.FxTarget.prototype.fxScope;

/** @interface
*/


ColladaLoader2.FxScope = function() {};

/** @type {!Object.<!string, !ColladaLoader2.FxTarget>}
*/


ColladaLoader2.FxScope.prototype.sids;

/** @interface
*/


ColladaLoader2.UrlTarget = function() {};

/** @type {?string}
*/


ColladaLoader2.UrlTarget.prototype.id;

/** @interface
*/


ColladaLoader2.SidTarget = function() {};

/** @type {?string}
*/


ColladaLoader2.SidTarget.prototype.sid;

/** @interface
*/


ColladaLoader2.SidScope = function() {};

/** @type {!Array.<!ColladaLoader2.SidTarget|!ColladaLoader2.SidScope>}
*/


ColladaLoader2.SidScope.prototype.sidChildren;

/** @interface
*/


ColladaLoader2.Link = function() {};

/** @type {!string}
*/


ColladaLoader2.Link.prototype.url;

/**
*   COLLADA URL addressing
*
*   See chapter 3, section "Adress Syntax"
*   Uses XML ids that are unique within the whole document.
*   Hyperlinks to ids start with a hash.
*   <element id="xyz">
*   <element source="#xyz">
*
*   @constructor
*   @struct
*   @implements {ColladaLoader2.Link}
*   @param {!string} url
*   @param {!ColladaLoader2.File} file
*/


ColladaLoader2.UrlLink = function(url, file) {
  /** @type {!ColladaLoader2.File}
  */
  this.file = file;
  /** @type {!string}
  */

  this.url = url.trim().replace(/^#/, "");
  /** @type {?ColladaLoader2.UrlTarget}
  */

  this.object = null;
  return this;
};

/**
*   Resolves the link
*
*   @return {?ColladaLoader2.UrlTarget}
*/


ColladaLoader2.UrlLink.prototype._resolve = function() {
  var object;

  object = this.file.dae.ids[this.url];
  if (object == null) {
    ColladaLoader2._log("Could not resolve URL #" + this.url, ColladaLoader2.messageError);
  }
  return object;
};

/**
*   Returns the link target
*
*   @return {?ColladaLoader2.UrlTarget}
*/


ColladaLoader2.UrlLink.prototype.getTarget = function() {
  if (this.object == null) {
    this.object = this._resolve();
  }
  return this.object;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.UrlLink.prototype.getInfo = function(indent, prefix) {
  return ColladaLoader2.graphNodeString(indent, prefix + ("<urlLink url='" + this.url + "'>\n"));
};

/**
*   COLLADA FX parameter addressing
*
*   See chapter 7, section "About Parameters"
*   Uses scoped ids that are unique within the given scope.
*   If the target is not defined within the same scope,
*   the search continues in the parent scope
*   <element sid="xyz">
*   <element texture="xyz">
*
*   @constructor
*   @struct
*   @implements {ColladaLoader2.Link}
*   @param {!string} url
*   @param {!ColladaLoader2.FxScope} scope
*   @param {!ColladaLoader2.File} file
*/


ColladaLoader2.FxLink = function(url, scope, file) {
  /** @type {!ColladaLoader2.File}
  */
  this.file = file;
  /** @type {!string}
  */

  this.url = url;
  /** @type {!ColladaLoader2.FxScope}
  */

  this.scope = scope;
  /** @type {?ColladaLoader2.FxTarget}
  */

  this.object = null;
  return this;
};

/**
*   Resolves the link
*
*   @return {?ColladaLoader2.FxTarget}
*/


ColladaLoader2.FxLink.prototype._resolve = function() {
  var object, scope;

  scope = this.scope;
  object = null;
  while ((object == null) && (scope != null)) {
    object = scope.sids[this.url];
    scope = scope.fxScope;
  }
  if (object == null) {
    ColladaLoader2._log("Could not resolve FX parameter #" + this.url, ColladaLoader2.messageError);
  }
  return object;
};

/**
*   Returns the link target
*
*   @return {?ColladaLoader2.FxTarget}
*/


ColladaLoader2.FxLink.prototype.getTarget = function() {
  if (this.object == null) {
    this.object = this._resolve();
  }
  return this.object;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.FxLink.prototype.getInfo = function(indent, prefix) {
  return ColladaLoader2.graphNodeString(indent, prefix + ("<fxLink url='" + this.url + "'>\n"));
};

/**
*   COLLADA SID addressing
*
*   See chapter 3, section "Adress Syntax"
*   Uses scoped ids that are unique within the parent element.
*   Adresses are anchored at a globally unique id and have a path of scoped ids.
*   <elementA id="xyz"><elementB sid="abc"></elementB></elementA>
*   <element target="xyz/abc">
*
*   @constructor
*   @struct
*   @implements {ColladaLoader2.Link}
*   @param {!string} url
*   @param {?string} parentId
*   @param {!ColladaLoader2.File} file
*/


ColladaLoader2.SidLink = function(parentId, url, file) {
  /** @type {!ColladaLoader2.File}
  */
  this.file = file;
  /** @type {!string}
  */

  this.url = url;
  /** @type {?string}
  */

  this.parentId = parentId;
  /** @type {?ColladaLoader2.SidTarget}
  */

  this.object = null;
  /** @type {?string}
  */

  this.id = null;
  /** @type {!Array.<!string>}
  */

  this.sids = [];
  /** @type {?string}
  */

  this.member = null;
  /** @type {?Array.<!number>}
  */

  this.indices = null;
  /** @type {!boolean}
  */

  this.dotSyntax = false;
  /** @type {!boolean}
  */

  this.arrSyntax = false;
  this._parseUrl();
  return this;
};

/**
*   Parses the URL into its components
*/


ColladaLoader2.SidLink.prototype._parseUrl = function() {
  var arrIndices, arrSyntax, dotSyntax, index, lastSid, parts, _i, _len;

  parts = this.url.split("/");
  this.id = parts.shift();
  if (this.id === ".") {
    this.id = this.parentId;
  }
  while (parts.length > 1) {
    this.sids.push(parts.shift());
  }
  if (parts.length > 0) {
    lastSid = parts[0];
    dotSyntax = lastSid.indexOf(".") >= 0;
    arrSyntax = lastSid.indexOf("(") >= 0;
    if (dotSyntax) {
      parts = lastSid.split(".");
      this.sids.push(parts.shift());
      this.member = parts.shift();
      this.dotSyntax = true;
    } else if (arrSyntax) {
      arrIndices = lastSid.split("(");
      this.sids.push(arrIndices.shift());
      this.indices = [];
      for (_i = 0, _len = arrIndices.length; _i < _len; _i++) {
        index = arrIndices[_i];
        this.indices.push(parseInt(index.replace(/\)/, ""), 10));
      }
      this.arrSyntax = true;
    } else {
      this.sids.push(lastSid);
    }
  }
};

/**
*   Performs a breadth-first search for an sid, starting with the root node
*
*   @param {!string} url
*   @param {!ColladaLoader2.SidScope} root
*   @param {!Array.<!string>} sids
*   @param {!boolean} errorIfNotFound
*   @return {?ColladaLoader2.SidTarget}
*/


ColladaLoader2.SidLink.findSidTarget = function(url, root, sids, errorIfNotFound) {
  var childObject, front, parentObject, queue, sid, sidChild, _i, _j, _len, _len1, _ref;

  parentObject = root;
  childObject = null;
  for (_i = 0, _len = sids.length; _i < _len; _i++) {
    sid = sids[_i];
    queue = [parentObject];
    while (queue.length !== 0) {
      front = queue.shift();
      if (front.sid === sid) {
        childObject = front;
        break;
      }
      if (front.sidChildren != null) {
        _ref = front.sidChildren;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          sidChild = _ref[_j];
          queue.push(sidChild);
        }
      }
    }
    if ((childObject == null) && errorIfNotFound) {
      ColladaLoader2._log("Could not resolve SID #" + url + ", missing SID part " + sid, ColladaLoader2.messageError);
      return null;
    }
    parentObject = childObject;
  }
  return childObject;
};

/**
*   Resolves the link
*
*   @return {?ColladaLoader2.SidTarget}
*/


ColladaLoader2.SidLink.prototype._resolve = function() {
  var object, root;

  if (this.id == null) {
    ColladaLoader2._log("Could not resolve SID #" + this.url + ", link has no ID", ColladaLoader2.messageError);
    return null;
  }
  root = this.file.dae.ids[this.id];
  if (root == null) {
    ColladaLoader2._log("Could not resolve SID #" + this.url + ", missing base ID " + this.id, ColladaLoader2.messageError);
    return null;
  }
  object = ColladaLoader2.SidLink.findSidTarget(this.url, root, this.sids, true);
  return object;
};

/**
*   Returns the link target
*
*   @return {?ColladaLoader2.SidTarget}
*/


ColladaLoader2.SidLink.prototype.getTarget = function() {
  if (this.object == null) {
    this.object = this._resolve();
  }
  return this.object;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.SidLink.prototype.getInfo = function(indent, prefix) {
  var output, str;

  str = "<sidLink id='" + this.id + "'";
  if (this.sids.length > 0) {
    str += ", sids='[";
    str += this.sids.join(",");
    str += "]'";
  }
  str += ">\n";
  return output = ColladaLoader2.graphNodeString(indent, prefix + str);
};

/**
*   Returns the target of a link if the target has the correct type
*
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @param {!function(...)} type
*   @return {?ColladaLoader2.UrlTarget|?ColladaLoader2.FxTarget|?ColladaLoader2.SidTarget}
*/


ColladaLoader2._getLinkTarget = function(link, type) {
  var object;

  if (link == null) {
    return null;
  }
  object = link.getTarget();
  if (object instanceof type) {
    return object;
  } else {
    if (object != null) {
      ColladaLoader2._reportInvalidTargetType(link, type);
    }
    return null;
  }
};

/**
*   ColladaLoader2.AnimationTarget
*   This is used as a base class for every object that can be animated
*   To use an animation target, first select an animation by name, id, or index
*   After that, apply keyframes of the selected animation
*
*   @constructor
*   @struct
*   @implements {ColladaLoader2.SidTarget}
*/


ColladaLoader2.AnimationTarget = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @struct
  */

  this.animTarget = {
    /** @type {!Array.<!ColladaLoader2.ThreejsAnimationChannel>}
    */

    channels: [],
    /** @type {!Array.<!ColladaLoader2.ThreejsAnimationChannel>}
    */

    activeChannels: [],
    /** @type {?number}
    */

    dataRows: null,
    /** @type {?number}
    */

    dataColumns: null
  };
  return this;
};

/**
*   Selects an animation using a custom filter
*   @param {!function(ColladaLoader2.ThreejsAnimationChannel, number):boolean} filter
*/


ColladaLoader2.AnimationTarget.prototype.selectAnimation = function(filter) {
  var channel, i, _i, _len, _ref;

  this.animTarget.activeChannels = [];
  _ref = this.animTarget.channels;
  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
    channel = _ref[i];
    if (filter(channel, i)) {
      this.animTarget.activeChannels.push(channel);
    }
  }
};

/**
*   Selects an animation by id
*   @param {!string} id
*/


ColladaLoader2.AnimationTarget.prototype.selectAnimationById = function(id) {
  this.selectAnimation(function(channel, i) {
    return channel.animation.id === id;
  });
};

/**
*   Selects an animation by name
*   @param {!string} name
*/


ColladaLoader2.AnimationTarget.prototype.selectAnimationByName = function(name) {
  this.selectAnimation(function(channel, i) {
    return channel.animation.name === name;
  });
};

/**
*   Selects all animations
*/


ColladaLoader2.AnimationTarget.prototype.selectAllAnimations = function() {
  this.selectAnimation(function(channel, i) {
    return true;
  });
};

/**
*   Applies the given keyframe of the previously selected animation
*   @param {!number} keyframe
*/


ColladaLoader2.AnimationTarget.prototype.applyAnimationKeyframe = function(keyframe) {
  throw new Error("applyAnimationKeyframe() not implemented");
};

/**
*   Saves the non-animated state of this object
*/


ColladaLoader2.AnimationTarget.prototype.initAnimationTarget = function() {
  throw new Error("initAnimationTarget() not implemented");
};

/**
*   Resets this object to the non-animated state
*/


ColladaLoader2.AnimationTarget.prototype.resetAnimation = function() {
  throw new Error("resetAnimation() not implemented");
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.AnimationTarget}
*/


ColladaLoader2.AnimationTarget.fromLink = function(link) {
  return /** @type{ColladaLoader2.AnimationTarget} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.AnimationTarget));
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.Asset = function() {
  this.unit = 1;
  this.upAxis = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Asset.prototype.getInfo = function(indent, prefix) {
  return ColladaLoader2.graphNodeString(indent, prefix + "<asset>\n");
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*   @implements {ColladaLoader2.SidScope}
*/


ColladaLoader2.VisualScene = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {!Array.<!ColladaLoader2.VisualSceneNode>}
  */

  this.children = [];
  /** @type {!Array.<!ColladaLoader2.SidScope|!ColladaLoader2.SidTarget>}
  */

  this.sidChildren = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.VisualScene.prototype.getInfo = function(indent, prefix) {
  var child, output, _i, _len, _ref;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<visualScene id='" + this.id + "'>\n"));
  if (this.children != null) {
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      output += ColladaLoader2.getNodeInfo(child, indent + 1, "child ");
    }
  }
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.VisualScene}
*/


ColladaLoader2.VisualScene.fromLink = function(link) {
  return /** @type{ColladaLoader2.VisualScene} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.VisualScene));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*   @implements {ColladaLoader2.SidTarget}
*   @implements {ColladaLoader2.SidScope}
*/


ColladaLoader2.VisualSceneNode = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.sid = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?string}
  */

  this.type = null;
  /** @type {?string}
  */

  this.layer = null;
  /** @type {?ColladaLoader2.VisualSceneNode|ColladaLoader2.VisualScene}
  */

  this.parent = null;
  /** @type {!Array.<!ColladaLoader2.VisualSceneNode>}
  */

  this.children = [];
  /** @type {!Array.<!ColladaLoader2.VisualSceneNode>}
  */

  this.sidChildren = [];
  /** @type {!Array.<!ColladaLoader2.NodeTransform>}
  */

  this.transformations = [];
  /** @type {!Array.<!ColladaLoader2.InstanceGeometry>}
  */

  this.geometries = [];
  /** @type {!Array.<!ColladaLoader2.InstanceController>}
  */

  this.controllers = [];
  /** @type {!Array.<!ColladaLoader2.InstanceLight>}
  */

  this.lights = [];
  /** @type {!Array.<!ColladaLoader2.InstanceCamera>}
  */

  this.cameras = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.VisualSceneNode.prototype.getInfo = function(indent, prefix) {
  var child, output, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<visualSceneNode id='" + this.id + "', sid='" + this.sid + "', name='" + this.name + "'>\n"));
  if (this.geometries != null) {
    _ref = this.geometries;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      output += ColladaLoader2.getNodeInfo(child, indent + 1, "geometry ");
    }
  }
  if (this.controllers != null) {
    _ref1 = this.controllers;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      child = _ref1[_j];
      output += ColladaLoader2.getNodeInfo(child, indent + 1, "controller ");
    }
  }
  if (this.lights != null) {
    _ref2 = this.lights;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      child = _ref2[_k];
      output += ColladaLoader2.getNodeInfo(child, indent + 1, "light ");
    }
  }
  if (this.cameras != null) {
    _ref3 = this.cameras;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      child = _ref3[_l];
      output += ColladaLoader2.getNodeInfo(child, indent + 1, "camera ");
    }
  }
  if (this.children != null) {
    _ref4 = this.children;
    for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
      child = _ref4[_m];
      output += ColladaLoader2.getNodeInfo(child, indent + 1, "child ");
    }
  }
  return output;
};

/**
*   Returns a three.js transformation matrix for this node
*   @param {!THREE.Matrix4} result
*/


ColladaLoader2.VisualSceneNode.prototype.getTransformMatrix = function(result) {
  var temp, transform, _i, _len, _ref;

  temp = new THREE.Matrix4;
  result.identity();
  _ref = this.transformations;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    transform = _ref[_i];
    transform.getTransformMatrix(temp);
    result.multiplyMatrices(result, temp);
  }
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.VisualSceneNode}
*/


ColladaLoader2.VisualSceneNode.fromLink = function(link) {
  return /** @type{ColladaLoader2.VisualSceneNode} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.VisualSceneNode));
};

/**
*   @constructor
*   @struct
*   @extends {ColladaLoader2.AnimationTarget}
*   @implements {ColladaLoader2.SidTarget}
*/


ColladaLoader2.NodeTransform = function() {
  ColladaLoader2.AnimationTarget.call(this);
  /** @type {?string}
  */

  this.sid = null;
  /** @type {?string}
  */

  this.type = null;
  /** @type {?Float32Array}
  */

  this.data = null;
  /** @type {?Float32Array}
  */

  this.originalData = null;
  /** @type {?ColladaLoader2.VisualSceneNode}
  */

  this.node = null;
  return this;
};

ColladaLoader2.NodeTransform.prototype = new ColladaLoader2.AnimationTarget();

/**
*   Computes the three.js transformation matrix for this node
*
*   @param {!THREE.Matrix4} result
*/


ColladaLoader2.NodeTransform.prototype.getTransformMatrix = function(result) {
  var axis;

  if (this.data == null) {
      ColladaLoader2._log("Transform data not defined, using identity transform", ColladaLoader2.messageWarning);
    result.identity();
    return;
  }
  switch (this.type) {
    case "matrix":
      ColladaLoader2._fillMatrix4RowMajor(this.data, 0, result);
      break;
    case "rotate":
      axis = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
      result.makeRotationAxis(axis, this.data[3] * ColladaLoader2.TO_RADIANS);
      break;
    case "translate":
      result.makeTranslation(this.data[0], this.data[1], this.data[2]);
      break;
    case "scale":
      result.makeScale(this.data[0], this.data[1], this.data[2]);
      break;
    default:
      ColladaLoader2._log("Transform type '" + this.type + "' not implemented, using identity transform", ColladaLoader2.messageWarning);
      result.identity();
  }
};

/**
*   Applies the given keyframe of the previously selected animation
*   @param {!number} keyframe
*/


ColladaLoader2.NodeTransform.prototype.applyAnimationKeyframe = function(keyframe) {
  var channel, i, outputData, _i, _j, _len, _ref, _ref1;

  _ref = this.animTarget.activeChannels;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    channel = _ref[_i];
    outputData = channel.outputData;
    for (i = _j = 0, _ref1 = channel.count - 1; _j <= _ref1; i = _j += 1) {
      this.data[channel.offset + i] = outputData[keyframe * channel.stride + i];
    }
  }
};

/**
*   Saves the non-animated state of this object
*/


ColladaLoader2.NodeTransform.prototype.initAnimationTarget = function() {
  var i, x, _i, _len, _ref;

  this.originalData = new Float32Array(this.data.length);
  _ref = this.data;
  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
    x = _ref[i];
    this.originalData[i] = this.data[i];
  }
  switch (this.type) {
    case "matrix":
      this.animTarget.dataColumns = 4;
      this.animTarget.dataRows = 4;
      break;
    case "rotate":
      this.animTarget.dataColumns = 4;
      this.animTarget.dataRows = 1;
      break;
    case "translate":
    case "scale":
      this.animTarget.dataColumns = 3;
      this.animTarget.dataRows = 1;
      break;
    default:
      this.animTarget.dataColumns = null;
      this.animTarget.dataRows = null;
      ColladaLoader2._log("Transform type '" + this.type + "' not implemented, animation will be broken", ColladaLoader2.messageWarning);
  }
};

/**
*   Resets this object to the non-animated state
*/


ColladaLoader2.NodeTransform.prototype.resetAnimation = function() {
  var i, x, _i, _len, _ref;

  _ref = this.originalData;
  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
    x = _ref[i];
    this.data[i] = this.originalData[i];
  }
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.NodeTransform}
*/


ColladaLoader2.NodeTransform.fromLink = function(link) {
  return /** @type{ColladaLoader2.NodeTransform} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.NodeTransform));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.SidScope}
*   @implements {ColladaLoader2.SidTarget}
*/


ColladaLoader2.InstanceGeometry = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.geometry = null;
  /** @type {!Array.<!ColladaLoader2.InstanceMaterial>}
  */

  this.materials = [];
  /** @type {!Array.<!ColladaLoader2.SidScope|!ColladaLoader2.SidTarget>}
  */

  this.sidChildren = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.InstanceGeometry.prototype.getInfo = function(indent, prefix) {
  var material, output, _i, _len, _ref;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<instanceGeometry>\n");
  output += ColladaLoader2.getNodeInfo(this.geometry, indent + 1, "geometry ");
  _ref = this.materials;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    material = _ref[_i];
    output += ColladaLoader2.getNodeInfo(material, indent + 1, "material ");
  }
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.InstanceGeometry}
*/


ColladaLoader2.InstanceGeometry.fromLink = function(link) {
  return /** @type{ColladaLoader2.InstanceGeometry} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.InstanceGeometry));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.SidScope}
*   @implements {ColladaLoader2.SidTarget}
*/


ColladaLoader2.InstanceController = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.controller = null;
  /** @type {!Array.<!ColladaLoader2.UrlLink>}
  */

  this.skeletons = [];
  /** @type {!Array.<!ColladaLoader2.InstanceMaterial>}
  */

  this.materials = [];
  /** @type {!Array.<!ColladaLoader2.SidScope|!ColladaLoader2.SidTarget>}
  */

  this.sidChildren = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.InstanceController.prototype.getInfo = function(indent, prefix) {
  var material, output, skeleton, _i, _j, _len, _len1, _ref, _ref1;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<instanceController>\n");
  output += ColladaLoader2.getNodeInfo(this.controller, indent + 1, "controller ");
  _ref = this.skeletons;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    skeleton = _ref[_i];
    output += ColladaLoader2.getNodeInfo(skeleton, indent + 1, "skeleton ");
  }
  _ref1 = this.materials;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    material = _ref1[_j];
    output += ColladaLoader2.getNodeInfo(material, indent + 1, "material ");
  }
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.InstanceController}
*/


ColladaLoader2.InstanceController.fromLink = function(link) {
  return /** @type{ColladaLoader2.InstanceController} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.InstanceController));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.SidTarget}
*/


ColladaLoader2.InstanceMaterial = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {?string}
  */

  this.symbol = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.material = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {!Object.<string, Object>}
  */

  this.vertexInputs = {};
  /** @type {!Object.<string, Object>}
  */

  this.params = {};
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.InstanceMaterial.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<instanceMaterial sid='" + this.sid + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.material, indent + 1, "material ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.InstanceMaterial}
*/


ColladaLoader2.InstanceMaterial.fromLink = function(link) {
  return /** @type{ColladaLoader2.InstanceMaterial} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.InstanceMaterial));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.SidTarget}
*   @implements {ColladaLoader2.SidScope}
*/


ColladaLoader2.InstanceLight = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.light = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {!Array.<!ColladaLoader2.SidScope|!ColladaLoader2.SidTarget>}
  */

  this.sidChildren = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.InstanceLight.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<instanceLight>\n");
  output += ColladaLoader2.getNodeInfo(this.light, indent + 1, "light ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.InstanceLight}
*/


ColladaLoader2.InstanceLight.fromLink = function(link) {
  return /** @type{ColladaLoader2.InstanceLight} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.InstanceLight));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.SidTarget}
*   @implements {ColladaLoader2.SidScope}
*/


ColladaLoader2.InstanceCamera = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.camera = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {!Array.<!ColladaLoader2.SidScope|!ColladaLoader2.SidTarget>}
  */

  this.sidChildren = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.InstanceCamera.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<instanceCamera>\n");
  output += ColladaLoader2.getNodeInfo(this.camera, indent + 1, "camera ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.InstanceCamera}
*/


ColladaLoader2.InstanceCamera.fromLink = function(link) {
  return /** @type{ColladaLoader2.InstanceCamera} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.InstanceCamera));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*/


ColladaLoader2.Image = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.initFrom = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Image.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<image id='" + this.id + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.initFrom, indent + 1, "initFrom ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Image}
*/


ColladaLoader2.Image.fromLink = function(link) {
  return /** @type{ColladaLoader2.Image} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Image));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*   @implements {ColladaLoader2.FxScope}
*/


ColladaLoader2.Effect = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {!Object.<string, !ColladaLoader2.FxTarget>}
  */

  this.sids = {};
  /** @type {!Array.<!ColladaLoader2.EffectParam>}
  */

  this.params = [];
  /** @type {?ColladaLoader2.EffectTechnique}
  */

  this.technique = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Effect.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<effect id='" + this.id + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.technique, indent + 1, "technique ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Effect}
*/


ColladaLoader2.Effect.fromLink = function(link) {
  return /** @type{ColladaLoader2.Effect} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Effect));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.FxTarget}
*   @implements {ColladaLoader2.FxScope}
*/


ColladaLoader2.EffectTechnique = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {!Object.<string, !ColladaLoader2.FxTarget>}
  */

  this.sids = {};
  /** @type {?ColladaLoader2.FxScope}
  */

  this.fxScope = null;
  /** @type {!Array.<!ColladaLoader2.EffectParam>}
  */

  this.params = [];
  /** @type {?string}
  */

  this.shading = null;
  /** @type {?ColladaLoader2.ColorOrTexture}
  */

  this.emission = null;
  /** @type {?ColladaLoader2.ColorOrTexture}
  */

  this.ambient = null;
  /** @type {?ColladaLoader2.ColorOrTexture}
  */

  this.diffuse = null;
  /** @type {?ColladaLoader2.ColorOrTexture}
  */

  this.specular = null;
  /** @type {?ColladaLoader2.ColorOrTexture}
  */

  this.reflective = null;
  /** @type {?ColladaLoader2.ColorOrTexture}
  */

  this.transparent = null;
  /** @type {?ColladaLoader2.ColorOrTexture}
  */

  this.bump = null;
  /** @type {?number}
  */

  this.shininess = null;
  /** @type {?number}
  */

  this.transparency = null;
  /** @type {?number}
  */

  this.reflectivity = null;
  /** @type {?number}
  */

  this.index_of_refraction = null;
  /** @type {?boolean}
  */

  this.double_sided = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.EffectTechnique.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<technique sid='" + this.sid + "'>\n"));
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.EffectTechnique}
*/


ColladaLoader2.EffectTechnique.fromLink = function(link) {
  return /** @type{ColladaLoader2.EffectTechnique} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.EffectTechnique));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.FxTarget}
*/


ColladaLoader2.EffectParam = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {?ColladaLoader2.FxScope}
  */

  this.fxScope = null;
  /** @type {?string}
  */

  this.semantic = null;
  /** @type {?ColladaLoader2.EffectSurface}
  */

  this.surface = null;
  /** @type {?ColladaLoader2.EffectSampler}
  */

  this.sampler = null;
  /** @type {?Float32Array}
  */

  this.floats = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.EffectParam.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<newparam sid='" + this.sid + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.surface, indent + 1, "surface ");
  output += ColladaLoader2.getNodeInfo(this.sampler, indent + 1, "sampler ");
  output += ColladaLoader2.getNodeInfo(this.floats, indent + 1, "floats ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.EffectParam}
*/


ColladaLoader2.EffectParam.fromLink = function(link) {
  return /** @type{ColladaLoader2.EffectParam} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.EffectParam));
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.EffectSurface = function() {
  /** @type {?string}
  */
  this.type = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.initFrom = null;
  /** @type {?string}
  */

  this.format = null;
  /** @type {?Float32Array}
  */

  this.size = null;
  /** @type {?Float32Array}
  */

  this.viewportRatio = null;
  /** @type {?number}
  */

  this.mipLevels = null;
  /** @type {?boolean}
  */

  this.mipmapGenerate = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.EffectSurface.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<surface>\n");
  output += ColladaLoader2.getNodeInfo(this.initFrom, indent + 1, "initFrom ");
  return output;
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.EffectSampler = function() {
  /** @type {?ColladaLoader2.FxLink}
  */
  this.surface = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.image = null;
  /** @type {?string}
  */

  this.wrapS = null;
  /** @type {?string}
  */

  this.wrapT = null;
  /** @type {?string}
  */

  this.minfilter = null;
  /** @type {?string}
  */

  this.magfilter = null;
  /** @type {?Float32Array}
  */

  this.borderColor = null;
  /** @type {?number}
  */

  this.mipmapMaxLevel = null;
  /** @type {?number}
  */

  this.mipmapBias = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.EffectSampler.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<sampler>\n");
  output += ColladaLoader2.getNodeInfo(this.image, indent + 1, "image ");
  output += ColladaLoader2.getNodeInfo(this.surface, indent + 1, "surface ");
  return output;
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.ColorOrTexture = function() {
  /** @type {?Float32Array}
  */
  this.color = null;
  /** @type {?ColladaLoader2.FxLink}
  */

  this.textureSampler = null;
  /** @type {?string}
  */

  this.texcoord = null;
  /** @type {?string}
  */

  this.opaque = null;
  /** @type {?string}
  */

  this.bumptype = null;
  return this;
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*/


ColladaLoader2.Material = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.effect = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Material.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<material id='" + this.id + "' name='" + this.name + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.effect, indent + 1, "effect ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Material}
*/


ColladaLoader2.Material.fromLink = function(link) {
  return /** @type{ColladaLoader2.Material} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Material));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*/


ColladaLoader2.Geometry = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {!Array.<!ColladaLoader2.Source>}
  */

  this.sources = [];
  /** @type {?ColladaLoader2.Vertices}
  */

  this.vertices = null;
  /** @type {!Array.<!ColladaLoader2.Triangles>}
  */

  this.triangles = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Geometry.prototype.getInfo = function(indent, prefix) {
  var output, source, tri, _i, _j, _len, _len1, _ref, _ref1;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<geometry id='" + this.id + "' name='" + this.name + "'>\n"));
  _ref = this.sources;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    source = _ref[_i];
    output += ColladaLoader2.getNodeInfo(source, indent + 1, "source ");
  }
  output += ColladaLoader2.getNodeInfo(this.vertices, indent + 1, "vertices ");
  _ref1 = this.triangles;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    tri = _ref1[_j];
    output += ColladaLoader2.getNodeInfo(tri, indent + 1, "triangles ");
  }
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Geometry}
*/


ColladaLoader2.Geometry.fromLink = function(link) {
  return /** @type{ColladaLoader2.Geometry} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Geometry));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*/


ColladaLoader2.Source = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?string}
  */

  this.sourceId = null;
  /** @type {?number}
  */

  this.count = null;
  /** @type {?number}
  */

  this.stride = null;
  /** @type {?number}
  */

  this.offset = null;
  /** @type {Int32Array|Uint8Array|Float32Array|Array.<!string>|null}
  */

  this.data = null;
  /** @type {!Object.<string, string>}
  */

  this.params = {};
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Source.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<source id='" + this.id + "' name='" + this.name + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.sourceId, indent + 1, "sourceId ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Source}
*/


ColladaLoader2.Source.fromLink = function(link) {
  return /** @type{ColladaLoader2.Source} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Source));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*/


ColladaLoader2.Vertices = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {!Array.<!ColladaLoader2.Input>}
  */

  this.inputs = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Vertices.prototype.getInfo = function(indent, prefix) {
  var input, output, _i, _len, _ref;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<vertices id='" + this.id + "' name='" + this.name + "'>\n"));
  _ref = this.inputs;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    input = _ref[_i];
    output += ColladaLoader2.getNodeInfo(input, indent + 1, "input ");
  }
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Vertices}
*/


ColladaLoader2.Vertices.fromLink = function(link) {
  return /** @type{ColladaLoader2.Vertices} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Vertices));
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.Triangles = function() {
  /** @type {?string}
  */
  this.name = null;
  /** @type {?string}
  */

  this.type = null;
  /** @type {?number}
  */

  this.count = null;
  /** @type {?string}
  */

  this.material = null;
  /** @type {!Array.<!ColladaLoader2.Input>}
  */

  this.inputs = [];
  /** @type {?Int32Array}
  */

  this.indices = null;
  /** @type {?Int32Array}
  */

  this.vcount = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Triangles.prototype.getInfo = function(indent, prefix) {
  var input, output, _i, _len, _ref;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<triangles name='" + this.name + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.material, indent + 1, "material ");
  _ref = this.inputs;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    input = _ref[_i];
    output += ColladaLoader2.getNodeInfo(input, indent + 1, "input ");
  }
  return output;
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.Input = function() {
  /** @type {?string}
  */
  this.semantic = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.source = null;
  /** @type {?number}
  */

  this.offset = null;
  /** @type {?number}
  */

  this.set = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Input.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<input semantic=" + this.semantic + ">\n"));
  output += ColladaLoader2.getNodeInfo(this.source, indent + 1, "source ");
  return output;
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*/


ColladaLoader2.Controller = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?ColladaLoader2.Skin}
  */

  this.skin = null;
  /** @type {?ColladaLoader2.Morph}
  */

  this.morph = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Controller.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<controller id='" + this.id + "', name='" + this.name + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.skin, indent + 1, "skin ");
  output += ColladaLoader2.getNodeInfo(this.morph, indent + 1, "morph ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Controller}
*/


ColladaLoader2.Controller.fromLink = function(link) {
  return /** @type{ColladaLoader2.Controller} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Controller));
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.Skin = function() {
  /** @type {?ColladaLoader2.UrlLink}
  */
  this.source = null;
  /** @type {?Float32Array}
  */

  this.bindShapeMatrix = null;
  /** @type {!Array.<!ColladaLoader2.Source>}
  */

  this.sources = [];
  /** @type {?ColladaLoader2.Joints}
  */

  this.joints = null;
  /** @type {?ColladaLoader2.VertexWeights}
  */

  this.vertexWeights = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Skin.prototype.getInfo = function(indent, prefix) {
  var output, source, _i, _len, _ref;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<skin source='" + this.source + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.bindShapeMatrix, indent + 1, "bind_shape_matrix ");
  _ref = this.sources;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    source = _ref[_i];
    output += ColladaLoader2.getNodeInfo(source, indent + 1, "source ");
  }
  output += ColladaLoader2.getNodeInfo(this.joints, indent + 1, "joints ");
  output += ColladaLoader2.getNodeInfo(this.vertexWeights, indent + 1, "vertex_weights ");
  return output;
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.Morph = function() {
  return this;
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.Joints = function() {
  /** @type {?ColladaLoader2.Input}
  */
  this.joints = null;
  /** @type {?ColladaLoader2.Input}
  */

  this.invBindMatrices = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Joints.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<joints>\n");
  output += ColladaLoader2.getNodeInfo(this.joints, indent + 1, "joints ");
  output += ColladaLoader2.getNodeInfo(this.invBindMatrices, indent + 1, "invBindMatrices ");
  return output;
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.VertexWeights = function() {
  /** @type {!Array.<!ColladaLoader2.Input>}
  */
  this.inputs = [];
  /** @type {?Int32Array}
  */

  this.vcount = null;
  /** @type {?Int32Array}
  */

  this.v = null;
  /** @type {?ColladaLoader2.Input}
  */

  this.joints = null;
  /** @type {?ColladaLoader2.Input}
  */

  this.weights = null;
  /** @type {?number}
  */

  this.count = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.VertexWeights.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<vertex_weights>\n");
  output += ColladaLoader2.getNodeInfo(this.joints, indent + 1, "joints ");
  output += ColladaLoader2.getNodeInfo(this.weights, indent + 1, "weights ");
  return output;
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*/


ColladaLoader2.Animation = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?ColladaLoader2.Animation}
  */

  this.parent = null;
  /** @type {?string}
  */

  this.rootId = null;
  /** @type {?string}
  */

  this.rootName = null;
  /** @type {!Array.<!ColladaLoader2.Animation>}
  */

  this.animations = [];
  /** @type {!Array.<!ColladaLoader2.UrlLink>}
  */

  this.sources = [];
  /** @type {!Array.<!ColladaLoader2.UrlLink>}
  */

  this.samplers = [];
  /** @type {!Array.<!ColladaLoader2.Channel>}
  */

  this.channels = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Animation.prototype.getInfo = function(indent, prefix) {
  var animation, channel, output, sampler, source, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<animation id='" + this.id + "', name='" + this.name + "'>\n"));
  _ref = this.animations;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    animation = _ref[_i];
    output += ColladaLoader2.getNodeInfo(animation, indent + 1, "animation ");
  }
  _ref1 = this.sources;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    source = _ref1[_j];
    output += ColladaLoader2.getNodeInfo(source, indent + 1, "source ");
  }
  _ref2 = this.samplers;
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    sampler = _ref2[_k];
    output += ColladaLoader2.getNodeInfo(sampler, indent + 1, "sampler ");
  }
  _ref3 = this.channels;
  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
    channel = _ref3[_l];
    output += ColladaLoader2.getNodeInfo(channel, indent + 1, "channel ");
  }
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Animation}
*/


ColladaLoader2.Animation.fromLink = function(link) {
  return /** @type{ColladaLoader2.Animation} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Animation));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*/


ColladaLoader2.Sampler = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?ColladaLoader2.Input}
  */

  this.input = null;
  /** @type {!Array.<!ColladaLoader2.Input>}
  */

  this.outputs = [];
  /** @type {!Array.<!ColladaLoader2.Input>}
  */

  this.inTangents = [];
  /** @type {!Array.<!ColladaLoader2.Input>}
  */

  this.outTangents = [];
  /** @type {?string}
  */

  this.interpolation = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Sampler.prototype.getInfo = function(indent, prefix) {
  var o, output, t, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;

  output = ColladaLoader2.graphNodeString(indent, prefix + ("<sampler id='" + this.id + "'>\n"));
  output += ColladaLoader2.getNodeInfo(this.input, indent + 1, "input ");
  _ref = this.outputs;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    o = _ref[_i];
    output += ColladaLoader2.getNodeInfo(o, indent + 1, "output ");
  }
  _ref1 = this.inTangents;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    t = _ref1[_j];
    output += ColladaLoader2.getNodeInfo(t, indent + 1, "inTangent ");
  }
  _ref2 = this.outTangents;
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    t = _ref2[_k];
    output += ColladaLoader2.getNodeInfo(t, indent + 1, "outTangent ");
  }
  output += ColladaLoader2.getNodeInfo(this.interpolation, indent + 1, "interpolation ");
  return output;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Sampler}
*/


ColladaLoader2.Sampler.fromLink = function(link) {
  return /** @type{ColladaLoader2.Sampler} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Sampler));
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.Channel = function() {
  /** @type {?ColladaLoader2.Animation}
  */
  this.animation = null;
  /** @type {?ColladaLoader2.UrlLink}
  */

  this.source = null;
  /** @type {?ColladaLoader2.SidLink}
  */

  this.target = null;
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Channel.prototype.getInfo = function(indent, prefix) {
  var output;

  output = ColladaLoader2.graphNodeString(indent, prefix + "<channel>\n");
  output += ColladaLoader2.getNodeInfo(this.source, indent + 1, "source ");
  output += ColladaLoader2.getNodeInfo(this.target, indent + 1, "target ");
  return output;
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*   @implements {ColladaLoader2.SidScope}
*/


ColladaLoader2.Light = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?string}
  */

  this.type = null;
  /** @type {?Float32Array}
  */

  this.color = null;
  /** @type {!Object.<!string, !ColladaLoader2.LightParam>}
  */

  this.params = {};
  /** @type {!Array.<!ColladaLoader2.SidScope|!ColladaLoader2.SidTarget>}
  */

  this.sidChildren = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Light.prototype.getInfo = function(indent, prefix) {
  return ColladaLoader2.graphNodeString(indent, prefix + "<light>\n");
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Light}
*/


ColladaLoader2.Light.fromLink = function(link) {
  return /** @type{ColladaLoader2.Light} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Light));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.SidTarget}
*/


ColladaLoader2.LightParam = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?number}
  */

  this.value = null;
  return this;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.LightParam}
*/


ColladaLoader2.LightParam.fromLink = function(link) {
  return /** @type{ColladaLoader2.LightParam} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.LightParam));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.UrlTarget}
*   @implements {ColladaLoader2.SidScope}
*/


ColladaLoader2.Camera = function() {
  /** @type {?string}
  */
  this.id = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?string}
  */

  this.type = null;
  /** @type {!Object.<!string, !ColladaLoader2.CameraParam>}
  */

  this.params = {};
  /** @type {!Array.<!ColladaLoader2.SidScope|!ColladaLoader2.SidTarget>}
  */

  this.sidChildren = [];
  return this;
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.Camera.prototype.getInfo = function(indent, prefix) {
  return ColladaLoader2.graphNodeString(indent, prefix + "<camera>\n");
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.Camera}
*/


ColladaLoader2.Camera.fromLink = function(link) {
  return /** @type{ColladaLoader2.Camera} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.Camera));
};

/**
*   @constructor
*   @struct
*   @implements {ColladaLoader2.SidTarget}
*/


ColladaLoader2.CameraParam = function() {
  /** @type {?string}
  */
  this.sid = null;
  /** @type {?string}
  */

  this.name = null;
  /** @type {?number}
  */

  this.value = null;
  return this;
};

/**
*   @param {?ColladaLoader2.UrlLink|?ColladaLoader2.FxLink|?ColladaLoader2.SidLink|undefined} link
*   @return {?ColladaLoader2.CameraParam}
*/


ColladaLoader2.CameraParam.fromLink = function(link) {
  return /** @type{ColladaLoader2.CameraParam} */ (ColladaLoader2._getLinkTarget(link, ColladaLoader2.CameraParam));
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.ThreejsAnimationChannel = function() {
  /** @type {?Float32Array}
  */
  this.inputData = null;
  /** @type {Array.<string>|Float32Array|Int32Array|Uint8Array|null}
  */

  this.outputData = null;
  /** @type {?number}
  */

  this.offset = null;
  /** @type {?number}
  */

  this.stride = null;
  /** @type {?number}
  */

  this.count = null;
  /** @type {?string}
  */

  this.semantic = null;
  /** @type {?ColladaLoader2.Animation}
  */

  this.animation = null;
  return this;
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.ThreejsSkeletonBone = function() {
  /** @type {?number}
  */
  this.index = null;
  /** @type {?ColladaLoader2.VisualSceneNode}
  */

  this.node = null;
  /** @type {?string}
  */

  this.sid = null;
  /** @type {?ColladaLoader2.ThreejsSkeletonBone}
  */

  this.parent = null;
  /** @type {?boolean}
  */

  this.isAnimated = null;
  /** @type {!THREE.Matrix4}
  */

  this.matrix = new THREE.Matrix4;
  /** @type {!THREE.Matrix4}
  */

  this.worldMatrix = new THREE.Matrix4;
  /** @type {!THREE.Matrix4}
  */

  this.invBindMatrix = new THREE.Matrix4;
  /** @type {!THREE.Matrix4}
  */

  this.skinMatrix = new THREE.Matrix4;
  /** @type {!boolean}
  */

  this.worldMatrixDirty = true;
  return this;
};

/**
*   Computes the world transformation matrix
*   @return {!THREE.Matrix4}
*/


ColladaLoader2.ThreejsSkeletonBone.prototype.getWorldMatrix = function() {
  if (this.worldMatrixDirty) {
    if (this.parent != null) {
      this.worldMatrix.multiplyMatrices(this.parent.getWorldMatrix(), this.matrix);
    } else {
      this.worldMatrix.copy(this.matrix);
    }
    this.worldMatrixDirty = false;
  }
  return this.worldMatrix;
};

/**
*   Applies the transformation from the associated animation channel (if any)
*   @param {!number} frame
*/


ColladaLoader2.ThreejsSkeletonBone.prototype.applyAnimation = function(frame) {
  var transform, _i, _len, _ref;

  if (this.isAnimated) {
    _ref = this.node.transformations;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      transform = _ref[_i];
      transform.applyAnimationKeyframe(frame);
    }
    this.node.getTransformMatrix(this.matrix);
  }
  this.worldMatrixDirty = true;
  return null;
};

/**
*   Updates the skin matrix
*   @param {!THREE.Matrix4} bindShapeMatrix
*/


ColladaLoader2.ThreejsSkeletonBone.prototype.updateSkinMatrix = function(bindShapeMatrix) {
  var worldMatrix;

  worldMatrix = this.getWorldMatrix();
  this.skinMatrix.multiplyMatrices(worldMatrix, this.invBindMatrix);
  this.skinMatrix.multiplyMatrices(this.skinMatrix, bindShapeMatrix);
  return null;
};

/**
*   @constructor
*   @struct
*/


ColladaLoader2.ThreejsMaterialMap = function() {
  /** @type {!Array.<!THREE.Material>}
  */
  this.materials = [];
  /** @type {!Object.<string, number>}
  */

  this.indices = {};
  /** @type {!boolean}
  */

  this.needTangents = false;
  return this;
};

/**
*   This class contains all state needed for parsing a COLLADA file
*
*   @constructor
*   @struct
*   @param {!ColladaLoader2} loader
*/


ColladaLoader2.File = function(loader) {
  var blockCommentWorkaround, key, value, _ref;

  blockCommentWorkaround = null;
  /** @type {?string}
  */

  this._url = null;
  /** @type {!string}
  */

  this._baseUrl = "";
  /** @type {!ColladaLoader2}
  */

  this._loader = loader;
  /** @dict
  */

  this._options = {};
  _ref = loader.options;
  for (key in _ref) {
    value = _ref[key];
    this._options[key] = value;
  }
  /** @type {?function(ColladaLoader2.File)}
  */

  this._readyCallback = null;
  /** @type {?function(ColladaLoader2.File, number)}
  */

  this._progressCallback = null;
  /** @struct
  */

  this.dae = {
    /** @type {!Object.<!string, !ColladaLoader2.UrlTarget>}
    */

    ids: {},
    /** @type {!Array.<!ColladaLoader2.AnimationTarget>}
    */

    animationTargets: [],
    /** @type {!Array.<!ColladaLoader2.Effect>}
    */

    libEffects: [],
    /** @type {!Array.<!ColladaLoader2.Material>}
    */

    libMaterials: [],
    /** @type {!Array.<!ColladaLoader2.Geometry>}
    */

    libGeometries: [],
    /** @type {!Array.<!ColladaLoader2.Controller>}
    */

    libControllers: [],
    /** @type {!Array.<!ColladaLoader2.Light>}
    */

    libLights: [],
    /** @type {!Array.<!ColladaLoader2.Camera>}
    */

    libCameras: [],
    /** @type {!Array.<!ColladaLoader2.Image>}
    */

    libImages: [],
    /** @type {!Array.<!ColladaLoader2.VisualScene>}
    */

    libVisualScenes: [],
    /** @type {!Array.<!ColladaLoader2.Animation>}
    */

    libAnimations: [],
    /** @type {?ColladaLoader2.Asset}
    */

    asset: null,
    /** @type {?ColladaLoader2.UrlLink}
    */

    scene: null
  };
  /** @struct
  */

  this.threejs = {
    /** @type {?THREE.Object3D}
    */

    scene: null,
    /** @type {!Array.<!THREE.Texture>}
    */

    images: [],
    /** @type {!Array.<!THREE.Geometry>}
    */

    geometries: [],
    /** @type {!Array.<!THREE.Material>}
    */

    materials: []
  };
  /**
  * @type {?THREE.Object3D}
  * @expose
  */

  this.scene = null;
  return this;
};

/**
*   Sets the file URL
*   @param {!string} url
*/


ColladaLoader2.File.prototype.setUrl = function(url) {
  var parts;

  if (url != null) {
    this._url = url;
    parts = url.split("/");
    parts.pop();
    this._baseUrl = (parts.length < 1 ? "." : parts.join("/")) + "/";
  } else {
    this._url = "";
    this._baseUrl = "";
  }
};

/**
*   Returns a string describing the contents of a COLLADA lib
*   @param {?Object} lib
*   @param {!number} indent
*   @param {!string} libname
*   @return {!string}
*/


ColladaLoader2.File.prototype.getLibInfo = function(lib, indent, libname) {
  var child, numElements, output, _i, _len;

  if (lib == null) {
    return "";
  }
  output = ColladaLoader2.graphNodeString(indent, libname + (" <" + libname + ">\n"));
  numElements = 0;
  for (_i = 0, _len = lib.length; _i < _len; _i++) {
    child = lib[_i];
    output += ColladaLoader2.getNodeInfo(child, indent + 1, "");
    numElements += 1;
  }
  if (numElements > 0) {
    return output;
  } else {
    return "";
  }
};

/**
*   @param {!number} indent
*   @param {!string} prefix
*   @return {!string}
*/


ColladaLoader2.File.prototype.getInfo = function(indent, prefix) {
  var output;

  output = "<collada url='" + this._url + "'>\n";
  output += ColladaLoader2.getNodeInfo(this.dae.asset, indent + 1, "asset ");
  output += ColladaLoader2.getNodeInfo(this.dae.scene, indent + 1, "scene ");
  output += this.getLibInfo(this.dae.libEffects, indent + 1, "library_effects");
  output += this.getLibInfo(this.dae.libMaterials, indent + 1, "library_materials");
  output += this.getLibInfo(this.dae.libGeometries, indent + 1, "library_geometries");
  output += this.getLibInfo(this.dae.libControllers, indent + 1, "library_controllers");
  output += this.getLibInfo(this.dae.libLights, indent + 1, "library_lights");
  output += this.getLibInfo(this.dae.libCameras, indent + 1, "library_cameras");
  output += this.getLibInfo(this.dae.libImages, indent + 1, "library_images");
  output += this.getLibInfo(this.dae.libVisualScenes, indent + 1, "library_visual_scenes");
  output += this.getLibInfo(this.dae.libAnimations, indent + 1, "library_animations");
  return output;
};

/**
*   Returns the value of an attribute as a float
*
*   @param {!Node} el
*   @param {!string} name
*   @param {?number} defaultValue
*   @param {!boolean} required
*   @return {?number}
*/


ColladaLoader2.File.prototype._getAttributeAsFloat = function(el, name, defaultValue, required) {
  var data;

  data = el.getAttribute(name);
  if (data != null) {
    return parseFloat(data);
  } else if (!required) {
    return defaultValue;
  } else {
    ColladaLoader2._log("Element " + el.nodeName + " is missing required attribute " + name + ". Using default value " + defaultValue + ".", ColladaLoader2.messageError);
    return defaultValue;
  }
};

/**
*   Returns the value of an attribute as an integer
*
*   @param {!Node} el
*   @param {!string} name
*   @param {?number} defaultValue
*   @param {!boolean} required
*   @return {?number}
*/


ColladaLoader2.File.prototype._getAttributeAsInt = function(el, name, defaultValue, required) {
  var data;

  data = el.getAttribute(name);
  if (data != null) {
    return parseInt(data, 10);
  } else if (!required) {
    return defaultValue;
  } else {
    ColladaLoader2._log("Element " + el.nodeName + " is missing required attribute " + name + ". Using default value " + defaultValue + ".", ColladaLoader2.messageError);
    return defaultValue;
  }
};

/**
*   Returns the value of an attribute as a string
*
*   @param {!Node} el
*   @param {!string} name
*   @param {?string} defaultValue
*   @param {!boolean} required
*   @return {?string}
*/


ColladaLoader2.File.prototype._getAttributeAsString = function(el, name, defaultValue, required) {
  var data;

  data = el.getAttribute(name);
  if (data != null) {
    return data;
  } else if (!required) {
    return defaultValue;
  } else {
    ColladaLoader2._log("Element " + el.nodeName + " is missing required attribute " + name + ". Using default value " + defaultValue + ".", ColladaLoader2.messageError);
    return defaultValue;
  }
};

/**
*   Returns the value of an attribute as a URL link
*
*   @param {!Node} el
*   @param {!string} name
*   @param {!boolean} required
*   @return {?ColladaLoader2.UrlLink}
*/


ColladaLoader2.File.prototype._getAttributeAsUrlLink = function(el, name, required) {
  var data;

  data = el.getAttribute(name);
  if (data != null) {
    return new ColladaLoader2.UrlLink(data, this);
  } else {
    if (required) {
      ColladaLoader2._log("Element " + el.nodeName + " is missing required attribute " + name + ".", ColladaLoader2.messageError);
    }
    return null;
  }
};

/**
*   Returns the value of an attribute as a sid link
*
*   @param {!Node} el
*   @param {!string} name
*   @param {?string} parentId
*   @param {!boolean} required
*   @return {?ColladaLoader2.SidLink}
*/


ColladaLoader2.File.prototype._getAttributeAsSidLink = function(el, name, parentId, required) {
  var data;

  data = el.getAttribute(name);
  if (data != null) {
    return new ColladaLoader2.SidLink(parentId, data, this);
  } else {
    if (required) {
      ColladaLoader2._log("Element " + el.nodeName + " is missing required attribute " + name + ".", ColladaLoader2.messageError);
    }
    return null;
  }
};

/**
*   Returns the value of an attribute as a fx link
*
*   @param {!Node} el
*   @param {!string} name
*   @param {!ColladaLoader2.FxScope} scope
*   @param {!boolean} required
*   @return {?ColladaLoader2.FxLink}
*/


ColladaLoader2.File.prototype._getAttributeAsFxLink = function(el, name, scope, required) {
  var data;

  data = el.getAttribute(name);
  if (data != null) {
    return new ColladaLoader2.FxLink(data, scope, this);
  } else {
    if (required) {
      ColladaLoader2._log("Element " + el.nodeName + " is missing required attribute " + name + ".", ColladaLoader2.messageError);
    }
    return null;
  }
};

/**
*   Inserts a new URL link target
*
*   @param {!ColladaLoader2.UrlTarget} object
*   @param {?Object} lib
*   @param {!boolean} needsId
*/


ColladaLoader2.File.prototype._addUrlTarget = function(object, lib, needsId) {
  var id;

  if (lib != null) {
    lib.push(object);
  }
  id = object.id;
  if (id == null) {
    if (needsId) {
      ColladaLoader2._log("Object has no ID.", ColladaLoader2.messageError);
    }
    return;
  }
  if (this.dae.ids[id] != null) {
    ColladaLoader2._log("There is already an object with ID " + id + ".", ColladaLoader2.messageError);
    return;
  }
  this.dae.ids[id] = object;
};

/**
*   Inserts a new FX link target
*
*   @param {!ColladaLoader2.FxTarget} object
*   @param {!ColladaLoader2.FxScope} scope
*/


ColladaLoader2.File.prototype._addFxTarget = function(object, scope) {
  var sid;

  sid = object.sid;
  if (sid == null) {
    ColladaLoader2._log("Cannot add a FX target: object has no SID.", ColladaLoader2.messageError);
    return;
  }
  if (scope.sids[sid] != null) {
    ColladaLoader2._log("There is already an FX target with SID " + sid + ".", ColladaLoader2.messageError);
    return;
  }
  object.fxScope = scope;
  scope.sids[sid] = object;
};

/**
*   Inserts a new SID link target
*
*   @param {!ColladaLoader2.SidTarget} object
*   @param {!ColladaLoader2.SidScope} parent
*/


ColladaLoader2.File.prototype._addSidTarget = function(object, parent) {
  if (parent.sidChildren == null) {
    parent.sidChildren = [];
  }
  parent.sidChildren.push(object);
};

/**
*   Parses the COLLADA XML document
*
*   @param {!XMLDocument} doc
*/


ColladaLoader2.File.prototype._parseXml = function(doc) {
  var child, colladaFound, _i, _len, _ref;

  if (doc.childNodes == null) {
    ColladaLoader2._log("Cannot parse document, no 'childNodes' property (not an XML document?).", ColladaLoader2.messageError);
  }
  if (doc.childNodes.length === 0) {
    ColladaLoader2._log("Cannot parse document, document is empty.", ColladaLoader2.messageError);
  } else {
    colladaFound = false;
    _ref = doc.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "COLLADA":
            if (colladaFound) {
              ColladaLoader2._log("Ignoring unexpected second top level COLLADA element.", ColladaLoader2.messageWarning);
            } else {
              colladaFound = true;
              this._parseCollada(child);
            }
            break;
          default:
            ColladaLoader2._reportUnexpectedChild(child);
        }
      }
    }
    if (!colladaFound) {
      ColladaLoader2._log("Cannot parse document, no COLLADA element.", ColladaLoader2.messageError);
    }
  }
};

/**
*   Parses a <COLLADA> element
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseCollada = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "asset":
          this._parseAsset(child);
          break;
        case "scene":
          this._parseScene(child);
          break;
        case "library_effects":
          this._parseLibEffect(child);
          break;
        case "library_materials":
          this._parseLibMaterial(child);
          break;
        case "library_geometries":
          this._parseLibGeometry(child);
          break;
        case "library_images":
          this._parseLibImage(child);
          break;
        case "library_visual_scenes":
          this._parseLibVisualScene(child);
          break;
        case "library_controllers":
          this._parseLibController(child);
          break;
        case "library_animations":
          this._parseLibAnimation(child);
          break;
        case "library_lights":
          this._parseLibLight(child);
          break;
        case "library_cameras":
          this._parseLibCamera(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <asset> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseAsset = function(el) {
  var child, _i, _len, _ref;

  if (!this.dae.asset) {
    this.dae.asset = new ColladaLoader2.Asset();
  }
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "unit":
          this.dae.asset.unit = this._getAttributeAsFloat(child, "meter", 1, false);
          break;
        case "up_axis":
          this.dae.asset.upAxis = child.textContent.toUpperCase().charAt(0);
          break;
        case "contributor":
        case "created":
        case "modified":
        case "revision":
        case "title":
        case "subject":
        case "keywords":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <scene> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseScene = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "instance_visual_scene":
          this.dae.scene = this._getAttributeAsUrlLink(child, "url", true);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <library_visual_scenes> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibVisualScene = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "visual_scene":
          this._parseVisualScene(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <visual_scene> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseVisualScene = function(el) {
  var child, scene, _i, _len, _ref;

  scene = new ColladaLoader2.VisualScene;
  scene.id = this._getAttributeAsString(el, "id", null, false);
  this._addUrlTarget(scene, this.dae.libVisualScenes, true);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "node":
          this._parseSceneNode(scene, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <node> element.
*
*   @param {!ColladaLoader2.VisualScene|!ColladaLoader2.VisualSceneNode} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseSceneNode = function(parent, el) {
  var child, node, _i, _len, _ref;

  node = new ColladaLoader2.VisualSceneNode;
  node.id = this._getAttributeAsString(el, "id", null, false);
  node.sid = this._getAttributeAsString(el, "sid", null, false);
  node.name = this._getAttributeAsString(el, "name", null, false);
  node.type = this._getAttributeAsString(el, "type", null, false);
  node.layer = this._getAttributeAsString(el, "layer", null, false);
  node.parent = parent;
  parent.children.push(node);
  this._addUrlTarget(node, null, false);
  this._addSidTarget(node, parent);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "instance_geometry":
          this._parseInstanceGeometry(node, child);
          break;
        case "instance_controller":
          this._parseInstanceController(node, child);
          break;
        case "instance_light":
          this._parseInstanceLight(node, child);
          break;
        case "instance_camera":
          this._parseInstanceCamera(node, child);
          break;
        case "matrix":
        case "rotate":
        case "translate":
        case "scale":
          this._parseTransformElement(node, child);
          break;
        case "node":
          this._parseSceneNode(node, child);
          break;
        case "extra":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <instance_geometry> element.
*
*   @param {!ColladaLoader2.VisualSceneNode} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseInstanceGeometry = function(parent, el) {
  var child, geometry, _i, _len, _ref;

  geometry = new ColladaLoader2.InstanceGeometry();
  geometry.geometry = this._getAttributeAsUrlLink(el, "url", true);
  geometry.sid = this._getAttributeAsString(el, "sid", null, false);
  parent.geometries.push(geometry);
  this._addSidTarget(geometry, parent);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "bind_material":
          this._parseBindMaterial(geometry, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <instance_controller> element.
*
*   @param {!ColladaLoader2.VisualSceneNode} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseInstanceController = function(parent, el) {
  var child, controller, _i, _len, _ref;

  controller = new ColladaLoader2.InstanceController();
  controller.controller = this._getAttributeAsUrlLink(el, "url", true);
  controller.sid = this._getAttributeAsString(el, "sid", null, false);
  controller.name = this._getAttributeAsString(el, "name", null, false);
  parent.controllers.push(controller);
  this._addSidTarget(controller, parent);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "skeleton":
          controller.skeletons.push(new ColladaLoader2.UrlLink(child.textContent, this));
          break;
        case "bind_material":
          this._parseBindMaterial(controller, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <bind_material> element.
*
*   @param {!ColladaLoader2.InstanceGeometry|!ColladaLoader2.InstanceController} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseBindMaterial = function(parent, el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "technique_common":
          this._parseBindMaterialTechnique(parent, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <bind_material>/<technique_common> element.
*
*   @param {!ColladaLoader2.InstanceGeometry|!ColladaLoader2.InstanceController} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseBindMaterialTechnique = function(parent, el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "instance_material":
          this._parseInstanceMaterial(parent, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <instance_material> element.
*
*   @param {!ColladaLoader2.InstanceGeometry|!ColladaLoader2.InstanceController} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseInstanceMaterial = function(parent, el) {
  var child, material, _i, _len, _ref;

  material = new ColladaLoader2.InstanceMaterial;
  material.symbol = this._getAttributeAsString(el, "symbol", null, false);
  material.material = this._getAttributeAsUrlLink(el, "target", true);
  parent.materials.push(material);
  this._addSidTarget(material, parent);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "bind_vertex_input":
          this._parseInstanceMaterialBindVertex(material, child);
          break;
        case "bind":
          this._parseInstanceMaterialBind(material, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <instance_material>/<bind_vertex_input> element.
*
*   @param {!ColladaLoader2.InstanceMaterial} material
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseInstanceMaterialBindVertex = function(material, el) {
  var inputSemantic, inputSet, semantic;

  semantic = this._getAttributeAsString(el, "semantic", null, true);
  inputSemantic = this._getAttributeAsString(el, "input_semantic", null, true);
  inputSet = this._getAttributeAsInt(el, "input_set", null, false);
  if ((semantic != null) && (inputSemantic != null)) {
    material.vertexInputs[semantic] = {
      inputSemantic: inputSemantic,
      inputSet: inputSet
    };
  } else {
    ColladaLoader2._log("Skipped a material vertex binding because of missing semantics.", ColladaLoader2.messageWarning);
  }
};

/**
*   Parses an <instance_material>/<bind> element.
*
*   @param {!ColladaLoader2.InstanceMaterial} material
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseInstanceMaterialBind = function(material, el) {
  var semantic, target;

  semantic = this._getAttributeAsString(el, "semantic", null, false);
  target = this._getAttributeAsSidLink(el, "target", null, true);
  if (semantic != null) {
    material.params[semantic] = {
      target: target
    };
  } else {
    ColladaLoader2._log("Skipped a material uniform binding because of missing semantics.", ColladaLoader2.messageWarning);
  }
};

/**
*   Parses a transformation element.
*
*   @param {!ColladaLoader2.VisualSceneNode} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseTransformElement = function(parent, el) {
  var expectedDataLength, transform;

  transform = new ColladaLoader2.NodeTransform;
  transform.sid = this._getAttributeAsString(el, "sid", null, false);
  transform.type = el.nodeName;
  transform.node = parent;
  parent.transformations.push(transform);
  this._addSidTarget(transform, parent);
  this.dae.animationTargets.push(transform);
  transform.data = ColladaLoader2._strToFloats(el.textContent);
  expectedDataLength = 0;
  switch (transform.type) {
    case "matrix":
      expectedDataLength = 16;
      break;
    case "rotate":
      expectedDataLength = 4;
      break;
    case "translate":
      expectedDataLength = 3;
      break;
    case "scale":
      expectedDataLength = 3;
      break;
    case "skew":
      expectedDataLength = 7;
      break;
    case "lookat":
      expectedDataLength = 9;
      break;
    default:
      ColladaLoader2._log("Unknown transformation type " + transform.type + ".", ColladaLoader2.messageError);
  }
  if (transform.data.length !== expectedDataLength) {
    ColladaLoader2._log("Wrong number of elements for transformation type '" + transform.type + "': expected " + expectedDataLength + ", found " + transform.data.length, ColladaLoader2.messageError);
  }
};

/**
*   Parses an <instance_light> element.
*
*   @param {!ColladaLoader2.VisualSceneNode} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseInstanceLight = function(parent, el) {
  var child, light, _i, _len, _ref;

  light = new ColladaLoader2.InstanceLight();
  light.light = this._getAttributeAsUrlLink(el, "url", true);
  light.sid = this._getAttributeAsString(el, "sid", null, false);
  light.name = this._getAttributeAsString(el, "name", null, false);
  parent.lights.push(light);
  this._addSidTarget(light, parent);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "extra":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <instance_camera> element.
*
*   @param {!ColladaLoader2.VisualSceneNode} parent
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseInstanceCamera = function(parent, el) {
  var camera, child, _i, _len, _ref;

  camera = new ColladaLoader2.InstanceCamera();
  camera.camera = this._getAttributeAsUrlLink(el, "url", true);
  camera.sid = this._getAttributeAsString(el, "sid", null, false);
  camera.name = this._getAttributeAsString(el, "name", null, false);
  parent.cameras.push(camera);
  this._addSidTarget(camera, parent);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "extra":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <library_effects> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibEffect = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "effect":
          this._parseEffect(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <effect> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseEffect = function(el) {
  var child, effect, _i, _len, _ref;

  effect = new ColladaLoader2.Effect;
  effect.id = this._getAttributeAsString(el, "id", null, true);
  this._addUrlTarget(effect, this.dae.libEffects, true);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "profile_COMMON":
          this._parseEffectProfileCommon(effect, child);
          break;
        case "profile":
          ColladaLoader2._log("Skipped non-common effect profile for effect " + effect.id + ".", ColladaLoader2.messageWarning);
          break;
        case "extra":
          this._parseTechniqueExtra(effect.technique, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <effect>/<profile_COMMON> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Effect} effect
*/


ColladaLoader2.File.prototype._parseEffectProfileCommon = function(effect, el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "newparam":
          this._parseEffectNewparam(effect, child);
          break;
        case "technique":
          this._parseEffectTechnique(effect, child);
          break;
        case "extra":
          this._parseTechniqueExtra(effect.technique, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <newparam> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Effect|!ColladaLoader2.EffectTechnique} scope
*/


ColladaLoader2.File.prototype._parseEffectNewparam = function(scope, el) {
  var child, param, _i, _len, _ref;

  param = new ColladaLoader2.EffectParam;
  param.sid = this._getAttributeAsString(el, "sid", null, false);
  this._addFxTarget(param, scope);
  scope.params.push(param);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "semantic":
          param.semantic = child.textContent;
          break;
        case "float":
          param.floats = ColladaLoader2._strToFloats(child.textContent);
          break;
        case "float2":
          param.floats = ColladaLoader2._strToFloats(child.textContent);
          break;
        case "float3":
          param.floats = ColladaLoader2._strToFloats(child.textContent);
          break;
        case "float4":
          param.floats = ColladaLoader2._strToFloats(child.textContent);
          break;
        case "surface":
          param.surface = this._parseEffectSurface(scope, child);
          break;
        case "sampler2D":
          param.sampler = this._parseEffectSampler(scope, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <newparam>/<surface> element.
*
*   @param {!Node} el
*   @return {!ColladaLoader2.EffectSurface}
*   @param {!ColladaLoader2.Effect|!ColladaLoader2.EffectTechnique} scope
*/


ColladaLoader2.File.prototype._parseEffectSurface = function(scope, el) {
  var child, surface, _i, _len, _ref;

  surface = new ColladaLoader2.EffectSurface;
  surface.type = this._getAttributeAsString(el, "type", null, true);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "init_from":
          surface.initFrom = new ColladaLoader2.UrlLink(child.textContent, this);
          break;
        case "format":
          surface.format = child.textContent;
          break;
        case "size":
          surface.size = ColladaLoader2._strToFloats(child.textContent);
          break;
        case "viewport_ratio":
          surface.viewportRatio = ColladaLoader2._strToFloats(child.textContent);
          break;
        case "mip_levels":
          surface.mipLevels = parseInt(child.textContent, 10);
          break;
        case "mipmap_generate":
          surface.mipmapGenerate = child.textContent;
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
  return surface;
};

/**
*   Parses a <newparam>/<sampler> element.
*
*   @param {!Node} el
*   @return {!ColladaLoader2.EffectSampler}
*   @param {!ColladaLoader2.Effect|!ColladaLoader2.EffectTechnique} scope
*/


ColladaLoader2.File.prototype._parseEffectSampler = function(scope, el) {
  var child, sampler, _i, _len, _ref;

  sampler = new ColladaLoader2.EffectSampler;
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "source":
          sampler.surface = new ColladaLoader2.FxLink(child.textContent, scope, this);
          break;
        case "instance_image":
          sampler.image = this._getAttributeAsUrlLink(child, "url", true);
          break;
        case "wrap_s":
          sampler.wrapS = child.textContent;
          break;
        case "wrap_t":
          sampler.wrapT = child.textContent;
          break;
        case "minfilter":
          sampler.minfilter = child.textContent;
          break;
        case "magfilter":
          sampler.magfilter = child.textContent;
          break;
        case "border_color":
          sampler.borderColor = ColladaLoader2._strToFloats(child.textContent);
          break;
        case "mipmap_maxlevel":
          sampler.mipmapMaxLevel = parseInt(child.textContent, 10);
          break;
        case "mipmap_bias":
          sampler.mipmapBias = parseFloat(child.textContent);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
  return sampler;
};

/**
*   Parses a <technique> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Effect} effect
*/


ColladaLoader2.File.prototype._parseEffectTechnique = function(effect, el) {
  var child, technique, _i, _len, _ref;

  technique = new ColladaLoader2.EffectTechnique;
  technique.sid = this._getAttributeAsString(el, "sid", null, false);
  this._addFxTarget(technique, effect);
  effect.technique = technique;
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "blinn":
        case "phong":
        case "lambert":
        case "constant":
          technique.shading = child.nodeName;
          this._parseTechniqueParam(technique, "COMMON", child);
          break;
        case "extra":
          this._parseTechniqueExtra(technique, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <technique>/<blinn|phong|lambert|constant> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.EffectTechnique} technique
*   @param {?string} profile
*/


ColladaLoader2.File.prototype._parseTechniqueParam = function(technique, profile, el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "newparam":
          this._parseEffectNewparam(technique, child);
          break;
        case "emission":
          technique.emission = this._parseEffectColorOrTexture(technique, child);
          break;
        case "ambient":
          technique.ambient = this._parseEffectColorOrTexture(technique, child);
          break;
        case "diffuse":
          technique.diffuse = this._parseEffectColorOrTexture(technique, child);
          break;
        case "specular":
          technique.specular = this._parseEffectColorOrTexture(technique, child);
          break;
        case "reflective":
          technique.reflective = this._parseEffectColorOrTexture(technique, child);
          break;
        case "transparent":
          technique.transparent = this._parseEffectColorOrTexture(technique, child);
          break;
        case "bump":
          technique.bump = this._parseEffectColorOrTexture(technique, child);
          break;
        case "shininess":
          technique.shininess = parseFloat(child.childNodes[1].textContent);
          break;
        case "reflectivity":
          technique.reflectivity = parseFloat(child.childNodes[1].textContent);
          break;
        case "transparency":
          technique.transparency = parseFloat(child.childNodes[1].textContent);
          break;
        case "index_of_refraction":
          technique.index_of_refraction = parseFloat(child.childNodes[1].textContent);
          break;
        case "double_sided":
          technique.double_sided = (parseFloat(child.textContent)) > 0;
          break;
        default:
          if (profile === "COMMON") {
            ColladaLoader2._reportUnexpectedChild(child);
          }
      }
    }
  }
};

/**
*   Parses a <technique>/<extra> element.
*
*   @param {!Node} el
*   @param {?ColladaLoader2.EffectTechnique} technique
*/


ColladaLoader2.File.prototype._parseTechniqueExtra = function(technique, el) {
  var child, profile, _i, _len, _ref;

  if (technique == null) {
    ColladaLoader2._log("Ignored element <extra>, because there is no <technique>.", ColladaLoader2.messageWarning);
    return;
  }
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "technique":
          profile = this._getAttributeAsString(child, "profile", null, true);
          this._parseTechniqueParam(technique, profile, child);
          break;
        default:
          ColladaLoader2._reportUnhandledExtra(child);
      }
    }
  }
};

/**
*   Parses a color or texture element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.EffectTechnique} technique
*   @return {!ColladaLoader2.ColorOrTexture}
*/


ColladaLoader2.File.prototype._parseEffectColorOrTexture = function(technique, el) {
  var child, colorOrTexture, _i, _len, _ref;

  colorOrTexture = new ColladaLoader2.ColorOrTexture();
  colorOrTexture.opaque = this._getAttributeAsString(el, "opaque", null, false);
  colorOrTexture.bumptype = this._getAttributeAsString(el, "bumptype", null, false);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "color":
          colorOrTexture.color = ColladaLoader2._strToColor(child.textContent);
          break;
        case "texture":
          colorOrTexture.textureSampler = this._getAttributeAsFxLink(child, "texture", technique, true);
          colorOrTexture.texcoord = this._getAttributeAsString(child, "texcoord", null, true);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
  return colorOrTexture;
};

/**
*   Parses a <lib_materials> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibMaterial = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "material":
          this._parseMaterial(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <material> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseMaterial = function(el) {
  var child, material, _i, _len, _ref;

  material = new ColladaLoader2.Material;
  material.id = this._getAttributeAsString(el, "id", null, true);
  material.name = this._getAttributeAsString(el, "name", null, false);
  this._addUrlTarget(material, this.dae.libMaterials, true);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "instance_effect":
          material.effect = this._getAttributeAsUrlLink(child, "url", true);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <library_geometries> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibGeometry = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "geometry":
          this._parseGeometry(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <geometry> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseGeometry = function(el) {
  var child, geometry, _i, _len, _ref;

  geometry = new ColladaLoader2.Geometry();
  geometry.id = this._getAttributeAsString(el, "id", null, true);
  geometry.name = this._getAttributeAsString(el, "name", null, false);
  this._addUrlTarget(geometry, this.dae.libGeometries, true);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "mesh":
          this._parseMesh(geometry, child);
          break;
        case "convex_mesh":
        case "spline":
          ColladaLoader2._log("Geometry type " + child.nodeName + " not supported.", ColladaLoader2.messageError);
          break;
        case "extra":
          this._parseGeometryExtra(geometry, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <mesh> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Geometry} geometry
*/


ColladaLoader2.File.prototype._parseMesh = function(geometry, el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "source":
          this._parseSource(geometry, child);
          break;
        case "vertices":
          this._parseVertices(geometry, child);
          break;
        case "triangles":
        case "polylist":
        case "polygons":
          this._parseTriangles(geometry, child);
          break;
        case "lines":
        case "linestrips":
        case "trifans":
        case "tristrips":
          ColladaLoader2._log("Geometry primitive type " + child.nodeName + " not supported.", ColladaLoader2.messageError);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <geometry>/<extra> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Geometry} geometry
*/


ColladaLoader2.File.prototype._parseGeometryExtra = function(geometry, el) {
  var child, profile, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "technique":
          profile = this._getAttributeAsString(child, "profile", null, true);
          this._parseGeometryExtraTechnique(geometry, profile, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <geometry>/<extra>/<technique> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Geometry} geometry
*   @param {?string} profile
*/


ColladaLoader2.File.prototype._parseGeometryExtraTechnique = function(geometry, profile, el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      ColladaLoader2._reportUnhandledExtra(child);
    }
  }
};

/**
*   Parses a <source> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Geometry|!ColladaLoader2.Animation|!ColladaLoader2.Skin} parent
*/


ColladaLoader2.File.prototype._parseSource = function(parent, el) {
  var child, source, _i, _len, _ref;

  source = new ColladaLoader2.Source;
  source.id = this._getAttributeAsString(el, "id", null, true);
  source.name = this._getAttributeAsString(el, "name", null, false);
  this._addUrlTarget(source, parent.sources, true);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "bool_array":
          source.sourceId = this._getAttributeAsString(child, "id", null, false);
          source.data = ColladaLoader2._strToBools(child.textContent);
          break;
        case "float_array":
          source.sourceId = this._getAttributeAsString(child, "id", null, false);
          source.data = ColladaLoader2._strToFloats(child.textContent);
          break;
        case "int_array":
          source.sourceId = this._getAttributeAsString(child, "id", null, false);
          source.data = ColladaLoader2._strToInts(child.textContent);
          break;
        case "IDREF_array":
        case "Name_array":
          source.sourceId = this._getAttributeAsString(child, "id", null, false);
          source.data = ColladaLoader2._strToStrings(child.textContent);
          break;
        case "technique_common":
          this._parseSourceTechniqueCommon(source, child);
          break;
        case "technique":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <vertices> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Geometry} geometry
*/


ColladaLoader2.File.prototype._parseVertices = function(geometry, el) {
  var child, vertices, _i, _len, _ref;

  vertices = new ColladaLoader2.Vertices;
  vertices.id = this._getAttributeAsString(el, "id", null, true);
  vertices.name = this._getAttributeAsString(el, "name", null, false);
  this._addUrlTarget(vertices, null, true);
  geometry.vertices = vertices;
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "input":
          vertices.inputs.push(this._parseInput(child, false));
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <triangles> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Geometry} geometry
*/


ColladaLoader2.File.prototype._parseTriangles = function(geometry, el) {
  var child, triangles, _i, _len, _ref;

  triangles = new ColladaLoader2.Triangles;
  triangles.name = this._getAttributeAsString(el, "name", null, false);
  triangles.material = this._getAttributeAsString(el, "material", null, false);
  triangles.count = this._getAttributeAsInt(el, "count", 0, true);
  triangles.type = el.nodeName;
  geometry.triangles.push(triangles);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "input":
          triangles.inputs.push(this._parseInput(child, true));
          break;
        case "vcount":
          triangles.vcount = ColladaLoader2._strToInts(child.textContent);
          break;
        case "p":
          triangles.indices = ColladaLoader2._strToInts(child.textContent);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
  return triangles;
};

/**
*   Parses a <source>/<technique_common> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Source} source
*/


ColladaLoader2.File.prototype._parseSourceTechniqueCommon = function(source, el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "accessor":
          this._parseAccessor(source, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <accessor> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Source} source
*/


ColladaLoader2.File.prototype._parseAccessor = function(source, el) {
  var child, sourceId, _i, _len, _ref;

  sourceId = this._getAttributeAsString(el, "source", null, true);
  source.count = this._getAttributeAsInt(el, "count", 0, true);
  source.stride = this._getAttributeAsInt(el, "stride", 1, false);
  source.offset = this._getAttributeAsInt(el, "offset", 0, false);
  if (sourceId !== "#" + source.sourceId) {
    ColladaLoader2._log("Non-local sources not supported, source data will be empty", ColladaLoader2.messageError);
  }
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "param":
          this._parseAccessorParam(source, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <accessor>/<param> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Source} source
*/


ColladaLoader2.File.prototype._parseAccessorParam = function(source, el) {
  var name, semantic, sid, type;

  name = this._getAttributeAsString(el, "name", null, false);
  semantic = this._getAttributeAsString(el, "semantic", null, false);
  type = this._getAttributeAsString(el, "type", null, true);
  sid = this._getAttributeAsString(el, "sid", null, false);
  if ((name != null) && (type != null)) {
    source.params[name] = type;
  } else if ((semantic != null) && (type != null)) {
    source.params[semantic] = type;
  } else {
    ColladaLoader2._log("Accessor param ignored due to missing type, name, or semantic", ColladaLoader2.messageWarning);
  }
};

/**
*   Creates a ColladaLoader2.Input object from an <input> element.
*
*   @param {!Node} el
*   @param {!boolean} shared
*   @return {!ColladaLoader2.Input}
*/


ColladaLoader2.File.prototype._parseInput = function(el, shared) {
  var input;

  input = new ColladaLoader2.Input;
  input.semantic = this._getAttributeAsString(el, "semantic", null, true);
  input.source = this._getAttributeAsUrlLink(el, "source", true);
  if (shared) {
    input.offset = this._getAttributeAsInt(el, "offset", 0, true);
    input.set = this._getAttributeAsInt(el, "set", null, false);
  }
  return input;
};

/**
*   Parses an <library_images> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibImage = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "image":
          this._parseImage(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <iimage> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseImage = function(el) {
  var child, image, _i, _len, _ref;

  image = new ColladaLoader2.Image;
  image.id = this._getAttributeAsString(el, "id", null, true);
  this._addUrlTarget(image, this.dae.libImages, true);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "init_from":
          image.initFrom = child.textContent;
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <library_controllers> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibController = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "controller":
          this._parseController(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <controller> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseController = function(el) {
  var child, controller, _i, _len, _ref;

  controller = new ColladaLoader2.Controller;
  controller.id = this._getAttributeAsString(el, "id", null, true);
  controller.name = this._getAttributeAsString(el, "name", null, false);
  this._addUrlTarget(controller, this.dae.libControllers, true);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "skin":
          this._parseSkin(controller, child);
          break;
        case "morph":
          this._parseMorph(controller, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <morph> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Controller} parent
*/


ColladaLoader2.File.prototype._parseMorph = function(parent, el) {
  ColladaLoader2._log("Morph controllers not implemented", ColladaLoader2.messageError);
};

/**
*   Parses a <skin> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Controller} parent
*/


ColladaLoader2.File.prototype._parseSkin = function(parent, el) {
  var child, skin, _i, _len, _ref;

  skin = new ColladaLoader2.Skin;
  skin.source = this._getAttributeAsUrlLink(el, "source", true);
  if ((parent.skin != null) || (parent.morph != null)) {
    ColladaLoader2._log("Controller already has a skin or morph", ColladaLoader2.messageError);
  }
  parent.skin = skin;
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "bind_shape_matrix":
          this._parseBindShapeMatrix(skin, child);
          break;
        case "source":
          this._parseSource(skin, child);
          break;
        case "joints":
          this._parseJoints(skin, child);
          break;
        case "vertex_weights":
          this._parseVertexWeights(skin, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <bind_shape_matrix> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Skin} parent
*/


ColladaLoader2.File.prototype._parseBindShapeMatrix = function(parent, el) {
  parent.bindShapeMatrix = ColladaLoader2._strToFloats(el.textContent);
};

/**
*   Parses a <joints> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Skin} parent
*/


ColladaLoader2.File.prototype._parseJoints = function(parent, el) {
  var child, input, inputs, joints, _i, _j, _len, _len1, _ref;

  joints = new ColladaLoader2.Joints;
  if (parent.joints != null) {
    ColladaLoader2._log("Skin already has a joints array", ColladaLoader2.messageError);
  }
  parent.joints = joints;
  inputs = [];
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "input":
          inputs.push(this._parseInput(child, false));
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
  for (_j = 0, _len1 = inputs.length; _j < _len1; _j++) {
    input = inputs[_j];
    switch (input.semantic) {
      case "JOINT":
        joints.joints = input;
        break;
      case "INV_BIND_MATRIX":
        joints.invBindMatrices = input;
        break;
      default:
        ColladaLoader2._log("Unknown joints input semantic " + input.semantic, ColladaLoader2.messageError);
    }
  }
};

/**
*   Parses a <vertex_weights> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Skin} parent
*/


ColladaLoader2.File.prototype._parseVertexWeights = function(parent, el) {
  var child, input, inputs, weights, _i, _j, _len, _len1, _ref;

  weights = new ColladaLoader2.VertexWeights;
  weights.count = this._getAttributeAsInt(el, "count", 0, true);
  if (parent.vertexWeights != null) {
    ColladaLoader2._log("Skin already has a vertex weight array", ColladaLoader2.messageError);
  }
  parent.vertexWeights = weights;
  inputs = [];
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "input":
          inputs.push(this._parseInput(child, true));
          break;
        case "vcount":
          weights.vcount = ColladaLoader2._strToInts(child.textContent);
          break;
        case "v":
          weights.v = ColladaLoader2._strToInts(child.textContent);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
  for (_j = 0, _len1 = inputs.length; _j < _len1; _j++) {
    input = inputs[_j];
    switch (input.semantic) {
      case "JOINT":
        weights.joints = input;
        break;
      case "WEIGHT":
        weights.weights = input;
        break;
      default:
        ColladaLoader2._log("Unknown vertex weight input semantic " + input.semantic, ColladaLoader2.messageError);
    }
  }
};

/**
*   Parses a <library_animations> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibAnimation = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "animation":
          this._parseAnimation(null, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses an <animation> element.
*
*   @param {!Node} el
*   @param {?ColladaLoader2.Animation} parent
*/


ColladaLoader2.File.prototype._parseAnimation = function(parent, el) {
  var animation, child, _i, _len, _ref;

  animation = new ColladaLoader2.Animation;
  animation.id = this._getAttributeAsString(el, "id", null, false);
  animation.name = this._getAttributeAsString(el, "name", null, false);
  animation.parent = parent;
  if (parent != null) {
    animation.rootId = parent.rootId;
    animation.rootName = parent.rootName;
  } else {
    animation.rootId = animation.id;
    animation.rootName = animation.name;
  }
  this._addUrlTarget(animation, (parent != null ? parent.animations : void 0) || this.dae.libAnimations, false);
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "animation":
          this._parseAnimation(animation, child);
          break;
        case "source":
          this._parseSource(animation, child);
          break;
        case "sampler":
          this._parseSampler(animation, child);
          break;
        case "channel":
          this._parseChannel(animation, child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <sampler> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Animation} parent
*/


ColladaLoader2.File.prototype._parseSampler = function(parent, el) {
  var child, input, inputs, sampler, _i, _j, _len, _len1, _ref;

  sampler = new ColladaLoader2.Sampler;
  sampler.id = this._getAttributeAsString(el, "id", null, false);
  if (sampler.id != null) {
    this._addUrlTarget(sampler, parent.samplers, false);
  }
  inputs = [];
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "input":
          inputs.push(this._parseInput(child, false));
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
  for (_j = 0, _len1 = inputs.length; _j < _len1; _j++) {
    input = inputs[_j];
    switch (input.semantic) {
      case "INPUT":
        sampler.input = input;
        break;
      case "OUTPUT":
        sampler.outputs.push(input);
        break;
      case "INTERPOLATION":
        sampler.interpolation = input;
        break;
      case "IN_TANGENT":
        sampler.inTangents.push(input);
        break;
      case "OUT_TANGENT":
        sampler.outTangents.push(input);
        break;
      default:
        ColladaLoader2._log("Unknown sampler input semantic " + input.semantic, ColladaLoader2.messageError);
    }
  }
};

/**
*   Parses a <channel> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Animation} parent
*/


ColladaLoader2.File.prototype._parseChannel = function(parent, el) {
  var channel, child, _i, _len, _ref;

  channel = new ColladaLoader2.Channel;
  channel.source = this._getAttributeAsUrlLink(el, "source", true);
  channel.target = this._getAttributeAsSidLink(el, "target", parent.id, true);
  parent.channels.push(channel);
  channel.animation = parent;
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      ColladaLoader2._reportUnexpectedChild(child);
    }
  }
};

/**
*   Parses a <library_lights> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibLight = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "light":
          this._parseLight(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <light> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLight = function(el) {
  var child, light, _i, _len, _ref;

  light = new ColladaLoader2.Light();
  light.id = this._getAttributeAsString(el, "id", null, true);
  light.name = this._getAttributeAsString(el, "name", null, false);
  if (light.id != null) {
    this._addUrlTarget(light, this.dae.libLights, true);
  }
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "technique_common":
          this._parseLightTechniqueCommon(child, light);
          break;
        case "extra":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <light>/<technique_common> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Light} light
*/


ColladaLoader2.File.prototype._parseLightTechniqueCommon = function(el, light) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "ambient":
          this._parseLightParams(child, "COMMON", light);
          break;
        case "directional":
          this._parseLightParams(child, "COMMON", light);
          break;
        case "point":
          this._parseLightParams(child, "COMMON", light);
          break;
        case "spot":
          this._parseLightParams(child, "COMMON", light);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <light>/<technique_common>/<...> element.
*
*   @param {!Node} el
*   @param {!string} profile
*   @param {!ColladaLoader2.Light} light
*/


ColladaLoader2.File.prototype._parseLightParams = function(el, profile, light) {
  var child, _i, _len, _ref;

  light.type = el.nodeName;
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "color":
          this._parseLightColor(child, profile, light);
          break;
        case "constant_attenuation":
          this._parseLightParam(child, profile, light);
          break;
        case "linear_attenuation":
          this._parseLightParam(child, profile, light);
          break;
        case "quadratic_attenuation":
          this._parseLightParam(child, profile, light);
          break;
        case "falloff_angle":
          this._parseLightParam(child, profile, light);
          break;
        case "falloff_exponent":
          this._parseLightParam(child, profile, light);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <light>/<...>/<...>/<color> element.
*
*   @param {!Node} el
*   @param {!string} profile
*   @param {!ColladaLoader2.Light} light
*/


ColladaLoader2.File.prototype._parseLightColor = function(el, profile, light) {
  light.color = ColladaLoader2._strToFloats(el.textContent);
};

/**
*   Parses a <light>/<...>/<...>/<...> element.
*
*   @param {!Node} el
*   @param {!string} profile
*   @param {!ColladaLoader2.Light} light
*/


ColladaLoader2.File.prototype._parseLightParam = function(el, profile, light) {
  var param;

  param = new ColladaLoader2.LightParam();
  param.sid = this._getAttributeAsString(el, "sid", null, false);
  param.name = el.nodeName;
  light.params[param.name] = param;
  this._addSidTarget(param, light);
  param.value = parseFloat(el.textContent);
};

/**
*   Parses a <library_cameras> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseLibCamera = function(el) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "camera":
          this._parseCamera(child);
          break;
        case "extra":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <camera> element.
*
*   @param {!Node} el
*/


ColladaLoader2.File.prototype._parseCamera = function(el) {
  var camera, child, _i, _len, _ref;

  camera = new ColladaLoader2.Camera;
  camera.id = this._getAttributeAsString(el, "id", null, true);
  if (camera.id != null) {
    this._addUrlTarget(camera, this.dae.libCameras, true);
  }
  camera.name = el.getAttribute("name");
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "asset":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        case "optics":
          this._parseCameraOptics(child, camera);
          break;
        case "imager":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        case "extra":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <camera>/<optics> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Camera} camera
*/


ColladaLoader2.File.prototype._parseCameraOptics = function(el, camera) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "technique_common":
          this._parseCameraTechniqueCommon(child, camera);
          break;
        case "technique":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        case "extra":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <camera>/<optics>/<technique_common> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Camera} camera
*/


ColladaLoader2.File.prototype._parseCameraTechniqueCommon = function(el, camera) {
  var child, _i, _len, _ref;

  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "orthographic":
          this._parseCameraParams(child, camera);
          break;
        case "perspective":
          this._parseCameraParams(child, camera);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <camera>/<optics>/<technique_common>/<...> element.
*
*   @param {!Node} el
*   @param {!ColladaLoader2.Camera} camera
*/


ColladaLoader2.File.prototype._parseCameraParams = function(el, camera) {
  var child, _i, _len, _ref;

  camera.type = el.nodeName;
  _ref = el.childNodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    if (child.nodeType === 1) {
      switch (child.nodeName) {
        case "xmag":
          this._parseCameraParam(child, camera);
          break;
        case "ymag":
          this._parseCameraParam(child, camera);
          break;
        case "xfov":
          this._parseCameraParam(child, camera);
          break;
        case "yfov":
          this._parseCameraParam(child, camera);
          break;
        case "aspect_ratio":
          this._parseCameraParam(child, camera);
          break;
        case "znear":
          this._parseCameraParam(child, camera);
          break;
        case "zfar":
          this._parseCameraParam(child, camera);
          break;
        case "extra":
          ColladaLoader2._reportUnhandledExtra(child);
          break;
        default:
          ColladaLoader2._reportUnexpectedChild(child);
      }
    }
  }
};

/**
*   Parses a <camera>/<optics>/<technique_common>/<...>/<...> element.
*   @param {!Node} el
*   @param {!ColladaLoader2.Camera} camera
*/


ColladaLoader2.File.prototype._parseCameraParam = function(el, camera) {
  var param;

  param = new ColladaLoader2.CameraParam();
  param.sid = this._getAttributeAsString(el, "sid", null, false);
  param.name = el.nodeName;
  camera.params[param.name] = param;
  this._addSidTarget(param, camera);
  param.value = parseFloat(el.textContent);
};

/**
*   Links all ColladaLoader2.Channels with their AnimationTargets
*/


ColladaLoader2.File.prototype._linkAnimations = function() {
  var animation, target, _i, _j, _len, _len1, _ref, _ref1;

  _ref = this.dae.animationTargets;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    target = _ref[_i];
    target.initAnimationTarget();
  }
  _ref1 = this.dae.libAnimations;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    animation = _ref1[_j];
    this._linkAnimationChannels(animation);
  }
};

/**
*   Links a ColladaLoader2.Channel with its AnimationTarget
*
*   @param {!ColladaLoader2.Animation} animation
*/


ColladaLoader2.File.prototype._linkAnimationChannels = function(animation) {
  var channel, child, input, inputSource, output, outputSource, sampler, target, targetLink, threejsChannel, _i, _j, _len, _len1, _ref, _ref1;

  _ref = animation.channels;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    channel = _ref[_i];
    target = ColladaLoader2.AnimationTarget.fromLink(channel.target);
    if (target == null) {
      ColladaLoader2._log("Animation channel has an invalid target '" + channel.target.url + "', animation ignored", ColladaLoader2.messageWarning);
      continue;
    }
    sampler = ColladaLoader2.Sampler.fromLink(channel.source);
    if (sampler == null) {
      ColladaLoader2._log("Animation channel has an invalid sampler '" + channel.source.url + "', animation ignored", ColladaLoader2.messageWarning);
      continue;
    }
    input = sampler.input;
    if (input == null) {
      ColladaLoader2._log("Animation channel has no input, animation ignored", ColladaLoader2.messageWarning);
      continue;
    }
    inputSource = ColladaLoader2.Source.fromLink(input.source);
    if (inputSource == null) {
      ColladaLoader2._log("Animation channel has no input data, animation ignored", ColladaLoader2.messageWarning);
      continue;
    }
    if (sampler.outputs.length > 1) {
      ColladaLoader2._log("Animation channel has more than one output, using only the first output", ColladaLoader2.messageWarning);
    }
    output = sampler.outputs[0];
    if (output == null) {
      ColladaLoader2._log("Animation channel has no output, animation ignored", ColladaLoader2.messageWarning);
      continue;
    }
    outputSource = ColladaLoader2.Source.fromLink(output.source);
    if (outputSource == null) {
      ColladaLoader2._log("Animation channel has no output data, animation ignored", ColladaLoader2.messageWarning);
      continue;
    }
    threejsChannel = new ColladaLoader2.ThreejsAnimationChannel;
    threejsChannel.outputData = outputSource.data;
    if (inputSource.data instanceof Float32Array) {
      threejsChannel.inputData = inputSource.data;
    } else {
      ColladaLoader2._log("Animation channel has non-float input data, animation ignored", ColladaLoader2.messageWarning);
      continue;
    }
    threejsChannel.stride = outputSource.stride;
    threejsChannel.animation = animation;
    targetLink = channel.target;
    if (targetLink.dotSyntax) {
      threejsChannel.semantic = targetLink.member;
      threejsChannel.count = 1;
      switch (threejsChannel.semantic) {
        case "X":
          threejsChannel.offset = 0;
          break;
        case "Y":
          threejsChannel.offset = 1;
          break;
        case "Z":
          threejsChannel.offset = 2;
          break;
        case "W":
          threejsChannel.offset = 3;
          break;
        case "R":
          threejsChannel.offset = 0;
          break;
        case "G":
          threejsChannel.offset = 1;
          break;
        case "B":
          threejsChannel.offset = 2;
          break;
        case "U":
          threejsChannel.offset = 0;
          break;
        case "V":
          threejsChannel.offset = 1;
          break;
        case "S":
          threejsChannel.offset = 0;
          break;
        case "T":
          threejsChannel.offset = 1;
          break;
        case "P":
          threejsChannel.offset = 2;
          break;
        case "Q":
          threejsChannel.offset = 3;
          break;
        case "ANGLE":
          threejsChannel.offset = 3;
          break;
        default:
          ColladaLoader2._log("Unknown semantic for '" + targetLink.url + "', animation ignored", ColladaLoader2.messageWarning);
          continue;
      }
    } else if (channel.target.arrSyntax) {
      switch (targetLink.indices.length) {
        case 1:
          threejsChannel.offset = targetLink.indices[0];
          break;
        case 2:
          threejsChannel.offset = targetLink.indices[0] * target.animTarget.dataRows + targetLink.indices[1];
          break;
        default:
          ColladaLoader2._log("Invalid number of indices for '" + targetLink.url + "', animation ignored", ColladaLoader2.messageWarning);
          continue;
      }
      threejsChannel.count = 1;
    } else {
      threejsChannel.offset = 0;
      threejsChannel.count = target.animTarget.dataColumns * target.animTarget.dataRows;
    }
    target.animTarget.channels.push(threejsChannel);
  }
  _ref1 = animation.animations;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    child = _ref1[_j];
    this._linkAnimationChannels(child);
  }
};

/**
*   Creates the three.js scene graph
*/


ColladaLoader2.File.prototype._createSceneGraph = function() {
  var daeChild, daeScene, threejsScene, _i, _len, _ref;

  daeScene = ColladaLoader2.VisualScene.fromLink(this.dae.scene);
  if (daeScene == null) {
    return;
  }
  threejsScene = new THREE.Object3D();
  this.threejs.scene = threejsScene;
  _ref = daeScene.children;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    daeChild = _ref[_i];
    this._createSceneGraphNode(daeChild, threejsScene);
  }
  this.scene = threejsScene;
};

/**
*   Sets the transformation of a scene node
*
*   @param {!ColladaLoader2.VisualSceneNode} daeNode
*   @param {!THREE.Object3D} threejsNode
*/


ColladaLoader2.File.prototype._setNodeTransformation = function(daeNode, threejsNode) {
  daeNode.getTransformMatrix(threejsNode.matrix);
  threejsNode.matrix.decompose(threejsNode.position, threejsNode.quaternion, threejsNode.scale);
  threejsNode.rotation.setFromQuaternion(threejsNode.quaternion);
};

/**
*   Creates a three.js scene graph node
*
*   @param {!ColladaLoader2.VisualSceneNode} daeNode
*   @param {!THREE.Object3D} threejsParent
*/


ColladaLoader2.File.prototype._createSceneGraphNode = function(daeNode, threejsParent) {
  var daeCamera, daeChild, daeController, daeGeometry, daeLight, threejsCamera, threejsChild, threejsChildren, threejsLight, threejsMesh, threejsNode, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4;

  threejsChildren = [];
  _ref = daeNode.geometries;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    daeGeometry = _ref[_i];
    threejsMesh = this._createStaticMesh(daeGeometry);
    if (threejsMesh != null) {
      threejsMesh.name = daeNode.name != null ? daeNode.name : "";
      threejsChildren.push(threejsMesh);
    }
  }
  _ref1 = daeNode.controllers;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    daeController = _ref1[_j];
    threejsMesh = this._createAnimatedMesh(daeController);
    if (threejsMesh != null) {
      threejsMesh.name = daeNode.name != null ? daeNode.name : "";
      threejsChildren.push(threejsMesh);
    }
  }
  _ref2 = daeNode.lights;
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    daeLight = _ref2[_k];
    threejsLight = this._createLight(daeLight);
    if (threejsLight != null) {
      threejsLight.name = daeNode.name != null ? daeNode.name : "";
      threejsChildren.push(threejsLight);
    }
  }
  _ref3 = daeNode.cameras;
  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
    daeCamera = _ref3[_l];
    threejsCamera = this._createCamera(daeCamera);
    if (threejsCamera != null) {
      threejsCamera.name = daeNode.name != null ? daeNode.name : "";
      threejsChildren.push(threejsCamera);
    }
  }
  if (threejsChildren.length > 1) {
    threejsNode = new THREE.Object3D();
    for (_m = 0, _len4 = threejsChildren.length; _m < _len4; _m++) {
      threejsChild = threejsChildren[_m];
      if (threejsChild != null) {
        threejsNode.add(threejsChild);
      }
    }
    threejsParent.add(threejsNode);
  } else if (threejsChildren.length === 1) {
    threejsNode = threejsChildren[0];
    threejsParent.add(threejsNode);
  } else if (threejsChildren.length === 0) {
    if (daeNode.type !== "JOINT") {
      ColladaLoader2._log("Collada node " + daeNode.name + " did not produce any threejs nodes", ColladaLoader2.messageWarning);
    }
    threejsNode = new THREE.Object3D();
    threejsParent.add(threejsNode);
  }
  this._setNodeTransformation(daeNode, threejsNode);
  _ref4 = daeNode.children;
  for (_n = 0, _len5 = _ref4.length; _n < _len5; _n++) {
    daeChild = _ref4[_n];
    this._createSceneGraphNode(daeChild, threejsNode);
  }
};

/**
*   Creates a three.js light
*
*   @param {!ColladaLoader2.InstanceLight} daeInstanceLight
*   @return {?THREE.Light}
*/


ColladaLoader2.File.prototype._createLight = function(daeInstanceLight) {
  var attConst, attLin, attQuad, colorHex, foAngle, foExp, light, threejslight, _ref, _ref1, _ref2, _ref3, _ref4;

  light = ColladaLoader2.Light.fromLink(daeInstanceLight.light);
  if (light == null) {
    ColladaLoader2._log("Light instance has no light, light ignored", ColladaLoader2.messageWarning);
    return null;
  }
  if (light.color == null) {
    ColladaLoader2._log("Light has no color, using white", ColladaLoader2.messageWarning);
    colorHex = 0xffffff;
  } else {
    colorHex = ColladaLoader2._colorToHex(light.color);
  }
  attConst = (_ref = light.params["constant_attenuation"]) != null ? _ref.value : void 0;
  attLin = (_ref1 = light.params["linear_attenuation"]) != null ? _ref1.value : void 0;
  attQuad = (_ref2 = light.params["quadratic_attenuation"]) != null ? _ref2.value : void 0;
  foAngle = (_ref3 = light.params["falloff_angle"]) != null ? _ref3.value : void 0;
  foExp = (_ref4 = light.params["falloff_exponent"]) != null ? _ref4.value : void 0;
  threejslight = null;
  switch (light.type) {
    case "ambient":
      threejslight = new THREE.AmbientLight(colorHex);
      break;
    case "directional":
      threejslight = new THREE.DirectionalLight(colorHex, 1);
      break;
    case "point":
      threejslight = new THREE.PointLight(colorHex, attConst, attLin);
      break;
    case "spot":
      threejslight = new THREE.SpotLight(colorHex, attConst, attLin, foAngle, foExp);
      break;
    default:
      ColladaLoader2._log("Unknown light type " + light.type + ", light ignored.", ColladaLoader2.messageError);
  }
  return threejslight;
};

/**
*   Creates a three.js camera
*
*   @param {!ColladaLoader2.InstanceCamera} daeInstanceCamera
*   @return {?THREE.Camera}
*/


ColladaLoader2.File.prototype._createCamera = function(daeInstanceCamera) {
  var aspect, camera, threejscamera, x_fov, x_mag, y_fov, y_mag, z_max, z_min, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  camera = ColladaLoader2.Camera.fromLink(daeInstanceCamera.camera);
  if (camera == null) {
    ColladaLoader2._log("Camera instance has no camera, camera ignored", ColladaLoader2.messageWarning);
    return null;
  }
  x_mag = (_ref = camera.params["xmag"]) != null ? _ref.value : void 0;
  y_mag = (_ref1 = camera.params["ymag"]) != null ? _ref1.value : void 0;
  x_fov = (_ref2 = camera.params["xfov"]) != null ? _ref2.value : void 0;
  y_fov = (_ref3 = camera.params["yfov"]) != null ? _ref3.value : void 0;
  aspect = (_ref4 = camera.params["aspect_ratio"]) != null ? _ref4.value : void 0;
  z_min = (_ref5 = camera.params["znear"]) != null ? _ref5.value : void 0;
  z_max = (_ref6 = camera.params["zfar"]) != null ? _ref6.value : void 0;
  threejscamera = null;
  switch (camera.type) {
    case "orthographic":
      if ((x_mag != null) && (y_mag != null)) {
        aspect = x_mag / y_mag;
      } else if ((y_mag != null) && (aspect != null)) {
        x_mag = y_mag * aspect;
      } else if ((x_mag != null) && (aspect != null)) {
        y_mag = x_mag / aspect;
      } else if (x_mag != null) {
        aspect = 1;
        y_mag = x_mag;
      } else if (y_mag != null) {
        aspect = 1;
        x_mag = y_mag;
      } else {
        ColladaLoader2._log("Not enough field of view parameters for an orthographic camera.", ColladaLoader2.messageError);
        return null;
      }
      threejscamera = new THREE.OrthographicCamera(-x_mag, +x_mag, -y_mag, +y_mag, z_min, z_max);
      break;
    case "perspective":
      if ((x_fov != null) && (y_fov != null)) {
        aspect = x_fov / y_fov;
      } else if ((y_fov != null) && (aspect != null)) {
        x_fov = y_fov * aspect;
      } else if ((x_fov != null) && (aspect != null)) {
        y_fov = x_fov / aspect;
      } else if (x_fov != null) {
        aspect = 1;
        y_fov = x_fov;
      } else if (y_fov != null) {
        aspect = 1;
        x_fov = y_fov;
      } else {
        ColladaLoader2._log("Not enough field of view parameters for a perspective camera.", ColladaLoader2.messageError);
        return null;
      }
      threejscamera = new THREE.PerspectiveCamera(y_fov, aspect, z_min, z_max);
      break;
    default:
      ColladaLoader2._log("Unknown camera type " + camera.type + ", camera ignored.", ColladaLoader2.messageError);
  }
  return threejscamera;
};

/**
*   Creates a three.js static mesh
*
*   @param {!ColladaLoader2.InstanceGeometry} daeInstanceGeometry
*   @return {?THREE.Mesh}
*/


ColladaLoader2.File.prototype._createStaticMesh = function(daeInstanceGeometry) {
  var daeGeometry, gnm, mesh, threejsGeometry, threejsMaterial;

  daeGeometry = ColladaLoader2.Geometry.fromLink(daeInstanceGeometry.geometry);
  if (daeGeometry == null) {
    ColladaLoader2._log("Geometry instance has no geometry, mesh ignored", ColladaLoader2.messageWarning);
    return null;
  }
  gnm = this._createGeometryAndMaterial(daeGeometry, daeInstanceGeometry.materials);
  threejsGeometry = gnm.geometry;
  threejsMaterial = gnm.material;
  mesh = new THREE.Mesh(threejsGeometry, threejsMaterial);
  return mesh;
};

/**
*   Creates a threejs geometry and a material
*
*   @param {!ColladaLoader2.Geometry} daeGeometry
*   @param {!Array.<!ColladaLoader2.InstanceMaterial>} daeInstanceMaterials
*   @return {{geometry:!THREE.Geometry,material:(!THREE.Material|!THREE.MeshFaceMaterial)}}
*/


ColladaLoader2.File.prototype._createGeometryAndMaterial = function(daeGeometry, daeInstanceMaterials) {
  var material, threejsGeometry, threejsMaterial, threejsMaterials, _i, _len, _ref;

  threejsMaterials = this._createMaterials(daeInstanceMaterials);
  threejsGeometry = this._createGeometry(daeGeometry, threejsMaterials);
  threejsMaterial = null;
  if (threejsMaterials.materials.length > 1) {
    threejsMaterial = new THREE.MeshFaceMaterial();
    _ref = threejsMaterials.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      material = _ref[_i];
      threejsMaterial.materials.push(material);
    }
  } else if (threejsMaterials.materials.length > 0) {
    threejsMaterial = threejsMaterials.materials[0];
  } else {
    threejsMaterial = this._createDefaultMaterial();
  }
  return {
    geometry: threejsGeometry,
    material: threejsMaterial
  };
};

/**
*   Creates a three.js animated mesh
*
*   @param {!ColladaLoader2.InstanceController} daeInstanceController
*   @return {?THREE.Mesh}
*/


ColladaLoader2.File.prototype._createAnimatedMesh = function(daeInstanceController) {
  var daeController;

  daeController = ColladaLoader2.Controller.fromLink(daeInstanceController.controller);
  if (daeController == null) {
    ColladaLoader2._log("Controller not found, mesh ignored", ColladaLoader2.messageWarning);
    return null;
  }
  if (daeController.skin != null) {
    return this._createSkinMesh(daeInstanceController, daeController);
  }
  if (daeController.morph != null) {
    return this._createMorphMesh(daeInstanceController, daeController);
  }
  ColladaLoader2._log("Controller has neither a skin nor a morph, mesh ignored", ColladaLoader2.messageWarning);
  return null;
};

/**
*   Creates a three.js skin animated mesh
*
*   @param {!ColladaLoader2.InstanceController} daeInstanceController
*   @param {!ColladaLoader2.Controller} daeController
*   @return {?THREE.Mesh}
*/


ColladaLoader2.File.prototype._createSkinMesh = function(daeInstanceController, daeController) {
  var bone, bones, daeInvBindMatricesSource, daeJointsSource, daeSkin, daeSkinGeometry, gnm, i, jointNode, jointSid, joints, mesh, parentBone, skeleton, skeletonLink, skeletonRootNodes, threejsGeometry, threejsMaterial, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;

  daeSkin = daeController.skin;
  if (daeSkin == null) {
    ColladaLoader2._log("Controller for a skinned mesh has no skin, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  daeSkinGeometry = ColladaLoader2.Geometry.fromLink(daeSkin.source);
  if (daeSkinGeometry == null) {
    ColladaLoader2._log("Skin for a skinned mesh has no geometry, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  if (!this._options["useAnimations"]) {
    gnm = this._createGeometryAndMaterial(daeSkinGeometry, daeInstanceController.materials);
    threejsGeometry = gnm.geometry;
    threejsMaterial = gnm.material;
    return new THREE.Mesh(threejsGeometry, threejsMaterial);
  }
  skeletonRootNodes = [];
  _ref = daeInstanceController.skeletons;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    skeletonLink = _ref[_i];
    skeleton = ColladaLoader2.VisualSceneNode.fromLink(skeletonLink);
    if (skeleton == null) {
      ColladaLoader2._log("Controller instance for a skinned mesh uses unknown skeleton " + skeleton + ", skeleton ignored", ColladaLoader2.messageError);
      continue;
    }
    skeletonRootNodes.push(skeleton);
  }
  if (skeletonRootNodes.length === 0) {
    ColladaLoader2._log("Controller instance for a skinned mesh has no skeleton, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  joints = daeSkin.joints;
  if (joints == null) {
    ColladaLoader2._log("Skin has no joints, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  daeJointsSource = ColladaLoader2.Source.fromLink((_ref1 = joints.joints) != null ? _ref1.source : void 0);
  if ((daeJointsSource == null) || (daeJointsSource.data == null)) {
    ColladaLoader2._log("Skin has no joints source, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  daeInvBindMatricesSource = ColladaLoader2.Source.fromLink((_ref2 = joints.invBindMatrices) != null ? _ref2.source : void 0);
  if ((daeInvBindMatricesSource == null) || (daeInvBindMatricesSource.data == null)) {
    ColladaLoader2._log("Skin has no inverse bind matrix source, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  if (daeJointsSource.data.length * 16 !== daeInvBindMatricesSource.data.length) {
    ColladaLoader2._log("Skin has an inconsistent length of joint data sources, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  if (!(daeInvBindMatricesSource.data instanceof Float32Array)) {
    ColladaLoader2._log("Skin inverse bind matrices use a non-numeric data source, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  bones = [];
  _ref3 = daeJointsSource.data;
  for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
    jointSid = _ref3[_j];
    jointNode = this._findJointNode(jointSid, skeletonRootNodes);
    if (jointNode == null) {
      ColladaLoader2._log("Joint " + jointSid + " not found for skin with skeletons " + ((skeletonRootNodes.map(function(node) {
        return node.id;
      })).join(', ')) + ", mesh ignored", ColladaLoader2.messageError);
      return null;
    }
    bone = this._createBone(jointNode, jointSid, bones);
    ColladaLoader2._fillMatrix4RowMajor(daeInvBindMatricesSource.data, bone.index * 16, bone.invBindMatrix);
  }
  if (this._options["verboseMessages"]) {
    ColladaLoader2._log("Skin contains " + bones.length + " bones", ColladaLoader2.messageInfo);
  }
  i = 0;
  while (i < bones.length) {
    bone = bones[i];
    i = i + 1;
    for (_k = 0, _len2 = bones.length; _k < _len2; _k++) {
      parentBone = bones[_k];
      if (bone.node.parent === parentBone.node) {
        bone.parent = parentBone;
        break;
      }
    }
    if ((bone.node.parent != null) && bone.node.parent instanceof ColladaLoader2.VisualSceneNode && (bone.parent == null)) {
      bone.parent = this._createBone(bone.node.parent, "", bones);
    }
  }
  if (this._options["verboseMessages"]) {
    ColladaLoader2._log("Skeleton contains " + bones.length + " bones", ColladaLoader2.messageInfo);
  }
  if (daeSkin.vertexWeights == null) {
    ColladaLoader2._log("Skin has no vertex weight data, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  if (daeSkin.vertexWeights.joints.source.url !== daeSkin.joints.joints.source.url) {
    ColladaLoader2._log("Skin uses different data sources for joints in <joints> and <vertex_weights>, this is not supported by this loader, mesh ignored", ColladaLoader2.messageError);
    return null;
  }
  gnm = this._createGeometryAndMaterial(daeSkinGeometry, daeInstanceController.materials);
  threejsGeometry = gnm.geometry;
  threejsMaterial = gnm.material;
  if (this._options["convertSkinsToMorphs"]) {
    if (this._addSkinMorphTargets(threejsGeometry, daeSkin, bones, threejsMaterial)) {
      return new THREE.MorphAnimMesh(threejsGeometry, threejsMaterial);
    } else {
      return new THREE.Mesh(threejsGeometry, threejsMaterial);
    }
  } else {
    if (this._addSkinBones(threejsGeometry, daeSkin, bones, threejsMaterial)) {
      mesh = new THREE.SkinnedMesh(threejsGeometry, threejsMaterial);
      mesh.boneInverses = [];
      _ref4 = threejsGeometry.bones;
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        bone = _ref4[_l];
        mesh.boneInverses.push(bone.inverse);
      }
      return mesh;
    } else {
      return new THREE.Mesh(threejsGeometry, threejsMaterial);
    }
  }
};

/**
*   Finds a node that is referenced by the given joint sid
*
*   @param {!string} jointSid
*   @param {!Array.<!ColladaLoader2.VisualSceneNode>} skeletonRootNodes
*   @return {?ColladaLoader2.VisualSceneNode}
*/


ColladaLoader2.File.prototype._findJointNode = function(jointSid, skeletonRootNodes) {
  var jointNode, sids, skeleton, _i, _len;

  jointNode = null;
  for (_i = 0, _len = skeletonRootNodes.length; _i < _len; _i++) {
    skeleton = skeletonRootNodes[_i];
    sids = jointSid.split("/");
    jointNode = ColladaLoader2.SidLink.findSidTarget(jointSid, skeleton, sids, false);
    if (jointNode != null) {
      break;
    }
  }
  if (jointNode instanceof ColladaLoader2.VisualSceneNode) {
    return jointNode;
  } else {
    return null;
  }
};

/**
*   Creates a bone object
*
*   @param {!ColladaLoader2.VisualSceneNode} boneNode
*   @param {!string} jointSid
*   @param {!Array.<!ColladaLoader2.ThreejsSkeletonBone>} bones
*   @return {!ColladaLoader2.ThreejsSkeletonBone}
*/


ColladaLoader2.File.prototype._createBone = function(boneNode, jointSid, bones) {
  var bone, transform, _i, _len, _ref;

  bone = new ColladaLoader2.ThreejsSkeletonBone;
  bone.sid = jointSid;
  bone.node = boneNode;
  _ref = boneNode.transformations;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    transform = _ref[_i];
    if (transform.animTarget.channels.length > 0) {
      bone.isAnimated = true;
      break;
    }
  }
  bone.matrix = new THREE.Matrix4;
  boneNode.getTransformMatrix(bone.matrix);
  bone.index = bones.length;
  bones.push(bone);
  return bone;
};

/**
*   Handle animations (morph target output)
*
*   @param {!THREE.Geometry} threejsGeometry
*   @param {!ColladaLoader2.Skin} daeSkin
*   @param {!Array.<!ColladaLoader2.ThreejsSkeletonBone>} bones
*   @param {!THREE.Material|!THREE.MeshFaceMaterial} threejsMaterial
*   @return {!boolean} true if succeeded
*/


ColladaLoader2.File.prototype._addSkinMorphTargets = function(threejsGeometry, daeSkin, bones, threejsMaterial) {
  var bindShapeMatrix, bone, boneIndex, boneWeight, boneWeightIndex, enableWarningInvalidWeight, enableWarningNoBones, i, sourceVertex, sourceVertices, srcVertex, tempVertex, timesteps, totalWeight, vertex, vertexCount, vertices, vindex, vwJoints, vwJointsSource, vwV, vwVcount, vwWeights, vwWeightsSource, w, weights, _i, _j, _k, _l, _len, _len1, _ref, _ref1;

  timesteps = this._prepareAnimations(bones);
  if (!timesteps > 0) {
    return false;
  }
  sourceVertices = threejsGeometry.vertices;
  vertexCount = sourceVertices.length;
  vwV = daeSkin.vertexWeights.v;
  vwVcount = daeSkin.vertexWeights.vcount;
  vwJointsSource = ColladaLoader2.Source.fromLink(daeSkin.vertexWeights.joints.source);
  vwWeightsSource = ColladaLoader2.Source.fromLink(daeSkin.vertexWeights.weights.source);
  vwJoints = vwJointsSource != null ? vwJointsSource.data : void 0;
  vwWeights = vwWeightsSource != null ? vwWeightsSource.data : void 0;
  if (vwWeights == null) {
    ColladaLoader2._log("Skin has no weights data, no morph targets added for mesh", ColladaLoader2.messageError);
    return false;
  }
  bindShapeMatrix = new THREE.Matrix4;
  if (daeSkin.bindShapeMatrix != null) {
    bindShapeMatrix = ColladaLoader2._floatsToMatrix4RowMajor(daeSkin.bindShapeMatrix, 0);
  }
  tempVertex = new THREE.Vector3;
  enableWarningNoBones = true;
  enableWarningInvalidWeight = true;
  for (i = _i = 0, _ref = timesteps - 1; _i <= _ref; i = _i += 1) {
    this._updateSkinMatrices(bones, bindShapeMatrix, i);
    vertices = [];
    for (_j = 0, _len = sourceVertices.length; _j < _len; _j++) {
      srcVertex = sourceVertices[_j];
      vertices.push(new THREE.Vector3());
    }
    vindex = 0;
    for (i = _k = 0, _len1 = vertices.length; _k < _len1; i = ++_k) {
      vertex = vertices[i];
      sourceVertex = sourceVertices[i];
      weights = vwVcount[i];
      totalWeight = 0;
      for (w = _l = 0, _ref1 = weights - 1; _l <= _ref1; w = _l += 1) {
        boneIndex = vwV[vindex];
        boneWeightIndex = vwV[vindex + 1];
        vindex += 2;
        boneWeight = vwWeights[boneWeightIndex];
        totalWeight += boneWeight;
        if (boneIndex >= 0) {
          bone = bones[boneIndex];
          tempVertex.copy(sourceVertex);
          tempVertex.applyMatrix4(bone.skinMatrix);
          tempVertex.multiplyScalar(boneWeight);
          vertex.add(tempVertex);
        } else {
          tempVertex.copy(sourceVertex);
          tempVertex.applyMatrix4(bindShapeMatrix);
          tempVertex.multiplyScalar(boneWeight);
          vertex.add(tempVertex);
        }
      }
      if (weights === 0) {
        vertex.copy(sourceVertex);
        if (enableWarningNoBones) {
          ColladaLoader2._log("Skinned vertex not influenced by any bone, some vertices will be unskinned", ColladaLoader2.messageWarning);
          enableWarningNoBones = false;
        }
      } else if (!((0.01 < totalWeight && totalWeight < 1e6))) {
        vertex.copy(sourceVertex);
        if (enableWarningInvalidWeight) {
          ColladaLoader2._log("Zero or infinite total weight for skinned vertex, some vertices will be unskinned", ColladaLoader2.messageWarning);
          enableWarningInvalidWeight = false;
        }
      } else {
        vertex.multiplyScalar(1 / totalWeight);
      }
    }
    if (vindex !== vwV.length) {
      ColladaLoader2._log("Skinning did not consume all weights", ColladaLoader2.messageError);
    }
    threejsGeometry.morphTargets.push({
      name: "target",
      vertices: vertices
    });
  }
  threejsGeometry.computeMorphNormals();
  this._materialEnableMorphing(threejsMaterial);
  return true;
};

/**
*   Enables morph animations on a material
*
*   @param {!THREE.Material|THREE.MeshFaceMaterial} threejsMaterial
*/


ColladaLoader2.File.prototype._materialEnableMorphing = function(threejsMaterial) {
  var material, _i, _len, _ref;

  if (threejsMaterial instanceof THREE.MeshFaceMaterial) {
    _ref = threejsMaterial.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      material = _ref[_i];
      material.morphTargets = true;
      material.morphNormals = true;
    }
  } else {
    threejsMaterial.morphTargets = true;
    threejsMaterial.morphNormals = true;
  }
};

/**
*   Enables skin animations on a material
*
*   @param {!THREE.Material|THREE.MeshFaceMaterial} threejsMaterial
*/


ColladaLoader2.File.prototype._materialEnableSkinning = function(threejsMaterial) {
  var material, _i, _len, _ref;

  if (threejsMaterial instanceof THREE.MeshFaceMaterial) {
    _ref = threejsMaterial.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      material = _ref[_i];
      material.skinning = true;
    }
  } else {
    threejsMaterial.skinning = true;
  }
};

/**
*   Prepares the given skeleton for animation
*
*   @param {!Array.<!ColladaLoader2.ThreejsSkeletonBone>} bones
*   @return {?number} The number of keyframes of the animation
*/


ColladaLoader2.File.prototype._prepareAnimations = function(bones) {
  var bone, channel, channelTimesteps, hasAnimation, timesteps, transform, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;

  timesteps = null;
  for (_i = 0, _len = bones.length; _i < _len; _i++) {
    bone = bones[_i];
    hasAnimation = false;
    _ref = bone.node.transformations;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      transform = _ref[_j];
      transform.resetAnimation();
      transform.selectAllAnimations();
      _ref1 = transform.animTarget.activeChannels;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        channel = _ref1[_k];
        hasAnimation = true;
        channelTimesteps = channel.inputData.length;
        if ((timesteps != null) && channelTimesteps !== timesteps) {
          ColladaLoader2._log("Inconsistent number of time steps, no morph targets added for mesh. Resample all animations to fix this.", ColladaLoader2.messageError);
          return null;
        }
        timesteps = channelTimesteps;
      }
    }
    if (this._options["verboseMessages"] && !hasAnimation) {
      ColladaLoader2._log("Joint '" + bone.sid + "' has no animation channel", ColladaLoader2.messageWarning);
    }
  }
  return timesteps;
};

/**
*   Updates the skinning matrices for the given skeleton, using the given animation keyframe
*
*   @param {!Array.<!ColladaLoader2.ThreejsSkeletonBone>} bones
*   @param {!THREE.Matrix4} bindShapeMatrix
*   @param {!number} keyframe
*/


ColladaLoader2.File.prototype._updateSkinMatrices = function(bones, bindShapeMatrix, keyframe) {
  var bone, _i, _j, _len, _len1;

  for (_i = 0, _len = bones.length; _i < _len; _i++) {
    bone = bones[_i];
    bone.applyAnimation(keyframe);
  }
  for (_j = 0, _len1 = bones.length; _j < _len1; _j++) {
    bone = bones[_j];
    bone.updateSkinMatrix(bindShapeMatrix);
  }
};

/**
*   Handle animations (skin output)
*
*   @param {!THREE.Geometry} threejsGeometry
*   @param {!ColladaLoader2.Skin} daeSkin
*   @param {!Array.<!ColladaLoader2.ThreejsSkeletonBone>} bones
*   @param {!THREE.Material|!THREE.MeshFaceMaterial} threejsMaterial
*   @return {!boolean} true if succeeded
*/


ColladaLoader2.File.prototype._addSkinBones = function(threejsGeometry, daeSkin, bones, threejsMaterial) {
  var bindShapeMatrix, bone, boneIndex, boneWeight, boneWeightIndex, bonesPerVertex, enableWarningInvalidWeight, enableWarningTooManyBones, i, indices, key, keyframe, pos, rot, scl, sourceVertices, threejsAnimation, threejsBone, threejsBoneAnimation, threejsBones, threejsSkinIndices, threejsSkinWeights, timesteps, totalWeight, vertex, vertexCount, vindex, vwJoints, vwJointsSource, vwV, vwVcount, vwWeights, vwWeightsSource, w, weightCount, weights, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _ref, _ref1, _ref2, _ref3;

  timesteps = this._prepareAnimations(bones);
  if (!timesteps > 0) {
    return false;
  }
  sourceVertices = threejsGeometry.vertices;
  vertexCount = sourceVertices.length;
  vwV = daeSkin.vertexWeights.v;
  vwVcount = daeSkin.vertexWeights.vcount;
  vwJointsSource = ColladaLoader2.Source.fromLink(daeSkin.vertexWeights.joints.source);
  vwWeightsSource = ColladaLoader2.Source.fromLink(daeSkin.vertexWeights.weights.source);
  vwJoints = vwJointsSource != null ? vwJointsSource.data : void 0;
  vwWeights = vwWeightsSource != null ? vwWeightsSource.data : void 0;
  if (vwWeights == null) {
    ColladaLoader2._log("Skin has no weights data, no skin added for mesh", ColladaLoader2.messageError);
    return false;
  }
  bindShapeMatrix = new THREE.Matrix4;
  if (daeSkin.bindShapeMatrix != null) {
    bindShapeMatrix = ColladaLoader2._floatsToMatrix4RowMajor(daeSkin.bindShapeMatrix, 0);
  }
  pos = new THREE.Vector3();
  rot = new THREE.Quaternion();
  scl = new THREE.Vector3();
  enableWarningTooManyBones = true;
  enableWarningInvalidWeight = true;
  threejsSkinIndices = [];
  threejsSkinWeights = [];
  vindex = 0;
  bonesPerVertex = 4;
  indices = [0, 0, 0, 0];
  weights = [0, 0, 0, 0];
  for (i = _i = 0, _len = sourceVertices.length; _i < _len; i = ++_i) {
    vertex = sourceVertices[i];
    weightCount = vwVcount[i];
    if (weightCount > bonesPerVertex) {
      if (enableWarningTooManyBones) {
        ColladaLoader2._log("Too many bones influence a vertex, some influences will be discarded. Threejs supports only " + bonesPerVertex + " bones per vertex.", ColladaLoader2.messageWarning);
        enableWarningTooManyBones = false;
      }
      weightCount = bonesPerVertex;
    }
    totalWeight = 0;
    for (w = _j = 0, _ref = weightCount - 1; _j <= _ref; w = _j += 1) {
      boneIndex = vwV[vindex];
      boneWeightIndex = vwV[vindex + 1];
      vindex += 2;
      boneWeight = vwWeights[boneWeightIndex];
      totalWeight += boneWeight;
      indices[w] = boneIndex;
      weights[w] = boneWeight;
    }
    for (w = _k = weights, _ref1 = bonesPerVertex - 1; _k <= _ref1; w = _k += 1) {
      indices[w] = 0;
      weights[w] = 0;
    }
    if (!((0.01 < totalWeight && totalWeight < 1e6))) {
      if (enableWarningInvalidWeight) {
        ColladaLoader2._log("Zero or infinite total weight for skinned vertex, skin will be broken", ColladaLoader2.messageWarning);
        enableWarningInvalidWeight = false;
      }
    } else {
      for (w = _l = 0, _ref2 = bonesPerVertex - 1; _l <= _ref2; w = _l += 1) {
        weights[w] /= totalWeight;
      }
    }
    threejsSkinIndices.push(new THREE.Vector4(indices[0], indices[1], indices[2], indices[3]));
    threejsSkinWeights.push(new THREE.Vector4(weights[0], weights[1], weights[2], weights[3]));
  }
  threejsGeometry.skinIndices = threejsSkinIndices;
  threejsGeometry.skinWeights = threejsSkinWeights;
  threejsBones = [];
  for (_m = 0, _len1 = bones.length; _m < _len1; _m++) {
    bone = bones[_m];
    threejsBone = {};
    if (bone.parent != null) {
      threejsBone["parent"] = bone.parent.index;
    } else {
      threejsBone["parent"] = -1;
    }
    bone.matrix.decompose(pos, rot, scl);
    threejsBone["name"] = bone.node.name;
    threejsBone["pos"] = [pos.x, pos.y, pos.z];
    threejsBone["scl"] = [scl.x, scl.y, scl.z];
    threejsBone["rotq"] = [rot.x, rot.y, rot.z, rot.w];
    threejsBone["rot"] = null;
    threejsBone.inverse = new THREE.Matrix4;
    threejsBone.inverse.multiplyMatrices(bone.invBindMatrix, bindShapeMatrix);
    threejsBones.push(threejsBone);
  }
  threejsGeometry.bones = threejsBones;
  threejsAnimation = {
    "name": "animation",
    "hierarchy": [],
    "fps": 30,
    "length": timesteps - 1
  };
  threejsGeometry.animation = threejsAnimation;
  for (_n = 0, _len2 = bones.length; _n < _len2; _n++) {
    bone = bones[_n];
    threejsBoneAnimation = {
      "parent": bone.index,
      "keys": []
    };
    threejsAnimation["hierarchy"].push(threejsBoneAnimation);
    for (keyframe = _o = 0, _ref3 = timesteps - 1; _o <= _ref3; keyframe = _o += 1) {
      bone.applyAnimation(keyframe);
      bone.updateSkinMatrix(bindShapeMatrix);
      bone.matrix.decompose(pos, rot, scl);
      key = {
        "time": keyframe,
        "pos": [pos.x, pos.y, pos.z],
        "scl": [scl.x, scl.y, scl.z],
        "rot": [rot.x, rot.y, rot.z, rot.w]
      };
      threejsBoneAnimation["keys"].push(key);
    }
  }
  this._materialEnableSkinning(threejsMaterial);
  return true;
};

/**
*   Creates a three.js morph animated mesh
*
*   @param {!ColladaLoader2.InstanceController} daeInstanceController
*   @param {!ColladaLoader2.Controller} daeController
*   @return {?THREE.Mesh}
*/


ColladaLoader2.File.prototype._createMorphMesh = function(daeInstanceController, daeController) {
  ColladaLoader2._log("Morph animated meshes not supported, mesh ignored", ColladaLoader2.messageError);
  return null;
};

/**
*   Creates a three.js geometry
*
*   @param {!ColladaLoader2.Geometry} daeGeometry
*   @param {!ColladaLoader2.ThreejsMaterialMap} materials
*   @return {!THREE.Geometry}
*/


ColladaLoader2.File.prototype._createGeometry = function(daeGeometry, materials) {
  var materialIndex, threejsGeometry, triangles, _i, _len, _ref;

  threejsGeometry = new THREE.Geometry();
  _ref = daeGeometry.triangles;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    triangles = _ref[_i];
    if (triangles.material != null) {
      materialIndex = materials.indices[triangles.material];
      if (materialIndex == null) {
        ColladaLoader2._log("Material symbol " + triangles.material + " has no bound material instance, using material with index 0", ColladaLoader2.messageError);
        materialIndex = 0;
      }
    } else {
      ColladaLoader2._log("Missing material index, using material with index 0", ColladaLoader2.messageError);
      materialIndex = 0;
    }
    this._addTrianglesToGeometry(daeGeometry, triangles, materialIndex, threejsGeometry);
  }
  threejsGeometry.computeFaceNormals();
  threejsGeometry.computeCentroids();
  if (materials.needTangents) {
    threejsGeometry.computeTangents();
  }
  threejsGeometry.computeBoundingBox();
  return threejsGeometry;
};

/**
*   Adds primitives to a threejs geometry
*
*   @param {!ColladaLoader2.Geometry} daeGeometry
*   @param {!ColladaLoader2.Triangles} triangles
*   @param {!number} materialIndex
*   @param {!THREE.Geometry} threejsGeometry
*/


ColladaLoader2.File.prototype._addTrianglesToGeometry = function(daeGeometry, triangles, materialIndex, threejsGeometry) {
  var baseOffset0, baseOffset1, baseOffset2, c, color, data, dataTriColor, dataTriNormal, dataTriTexcoord, dataVertColor, dataVertNormal, dataVertPos, dataVertTexcoord, face, faceVertexUvs, i, indices, input, inputTriColor, inputTriNormal, inputTriTexcoord, inputTriVertices, inputVertColor, inputVertNormal, inputVertPos, inputVertTexcoord, missingFaces, n0, n1, n2, normal, numExistingFaces, numExistingTexcoordSets, numNewFaces, numNewTexcoordSets, srcTriColor, srcTriNormal, srcTriTexcoord, srcTriVertices, srcVertColor, srcVertNormal, srcVertPos, srcVertTexcoord, t0, t1, t2, texcoord, triangleBaseOffset, triangleIndex, triangleStride, v0, v1, v2, vcount, vertexStride, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3,
    _this = this;

  inputTriVertices = null;
  inputTriNormal = null;
  inputTriColor = null;
  inputTriTexcoord = [];
  _ref = triangles.inputs;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    input = _ref[_i];
    switch (input.semantic) {
      case "VERTEX":
        inputTriVertices = input;
        break;
      case "NORMAL":
        inputTriNormal = input;
        break;
      case "COLOR":
        inputTriColor = input;
        break;
      case "TEXCOORD":
        inputTriTexcoord.push(input);
        break;
      default:
        ColladaLoader2._log("Unknown triangles input semantic " + input.semantic + " ignored", ColladaLoader2.messageWarning);
    }
  }
  srcTriVertices = ColladaLoader2.Vertices.fromLink(inputTriVertices.source);
  if (srcTriVertices == null) {
    ColladaLoader2._log("Geometry " + daeGeometry.id + " has no vertices", ColladaLoader2.messageError);
    return;
  }
  srcTriNormal = ColladaLoader2.Source.fromLink(inputTriNormal != null ? inputTriNormal.source : void 0);
  srcTriColor = ColladaLoader2.Source.fromLink(inputTriColor != null ? inputTriColor.source : void 0);
  srcTriTexcoord = inputTriTexcoord.map(function(x) {
    return ColladaLoader2.Source.fromLink(x != null ? x.source : void 0);
  });
  inputVertPos = null;
  inputVertNormal = null;
  inputVertColor = null;
  inputVertTexcoord = [];
  _ref1 = srcTriVertices.inputs;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    input = _ref1[_j];
    switch (input.semantic) {
      case "POSITION":
        inputVertPos = input;
        break;
      case "NORMAL":
        inputVertNormal = input;
        break;
      case "COLOR":
        inputVertColor = input;
        break;
      case "TEXCOORD":
        inputVertTexcoord.push(input);
        break;
      default:
        ColladaLoader2._log("Unknown vertices input semantic " + input.semantic + " ignored", ColladaLoader2.messageWarning);
    }
  }
  srcVertPos = ColladaLoader2.Source.fromLink(inputVertPos.source);
  if (srcVertPos == null) {
    ColladaLoader2._log("Geometry " + daeGeometry.id + " has no vertex positions", ColladaLoader2.messageError);
    return;
  }
  srcVertNormal = ColladaLoader2.Source.fromLink(inputVertNormal != null ? inputVertNormal.source : void 0);
  srcVertColor = ColladaLoader2.Source.fromLink(inputVertColor != null ? inputVertColor.source : void 0);
  srcVertTexcoord = inputVertTexcoord.map(function(x) {
    return ColladaLoader2.Source.fromLink(x != null ? x.source : void 0);
  });
  dataVertPos = this._createVector3Array(srcVertPos);
  dataVertNormal = this._createVector3Array(srcVertNormal);
  dataTriNormal = this._createVector3Array(srcTriNormal);
  dataVertColor = this._createColorArray(srcVertColor);
  dataTriColor = this._createColorArray(srcTriColor);
  dataVertTexcoord = srcVertTexcoord.map(function(x) {
    return _this._createUVArray(x);
  });
  dataTriTexcoord = srcTriTexcoord.map(function(x) {
    return _this._createUVArray(x);
  });
  threejsGeometry.vertices = dataVertPos;
  numNewTexcoordSets = dataVertTexcoord.length + dataTriTexcoord.length;
  numExistingTexcoordSets = threejsGeometry.faceVertexUvs.length;
  numNewFaces = triangles.count;
  numExistingFaces = threejsGeometry.faces.length;
  _ref2 = threejsGeometry.faceVertexUvs;
  for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
    faceVertexUvs = _ref2[i];
    if (i < numNewTexcoordSets) {
      missingFaces = faceVertexUvs.length - threejsGeometry.faces.length;
      this._addEmptyUVs(faceVertexUvs, missingFaces);
    } else {
      missingFaces = faceVertexUvs.length - threejsGeometry.faces.length + numNewFaces;
      this._addEmptyUVs(faceVertexUvs, missingFaces);
    }
  }
  while (threejsGeometry.faceVertexUvs.length < numNewTexcoordSets) {
    faceVertexUvs = [];
    this._addEmptyUVs(faceVertexUvs, numExistingFaces);
    threejsGeometry.faceVertexUvs.push(faceVertexUvs);
  }
  if (triangles.type !== "triangles") {
    vcount = triangles.vcount;
    for (_l = 0, _len3 = vcount.length; _l < _len3; _l++) {
      c = vcount[_l];
      if (c !== 3) {
        ColladaLoader2._log("Geometry " + daeGeometry.id + " has non-triangle polygons, geometry ignored", ColladaLoader2.messageError);
        return;
      }
    }
  }
  indices = triangles.indices;
  triangleStride = indices.length / triangles.count;
  vertexStride = triangleStride / 3;
  for (triangleIndex = _m = 0, _ref3 = triangles.count - 1; _m <= _ref3; triangleIndex = _m += 1) {
    triangleBaseOffset = triangleIndex * triangleStride;
    baseOffset0 = triangleBaseOffset + 0 * vertexStride;
    baseOffset1 = triangleBaseOffset + 1 * vertexStride;
    baseOffset2 = triangleBaseOffset + 2 * vertexStride;
    v0 = indices[baseOffset0 + inputTriVertices.offset];
    v1 = indices[baseOffset1 + inputTriVertices.offset];
    v2 = indices[baseOffset2 + inputTriVertices.offset];
    if (dataVertNormal != null) {
      normal = [dataVertNormal[v0], dataVertNormal[v1], dataVertNormal[v2]];
    } else if (dataTriNormal != null) {
      n0 = indices[baseOffset0 + inputTriNormal.offset];
      n1 = indices[baseOffset1 + inputTriNormal.offset];
      n2 = indices[baseOffset2 + inputTriNormal.offset];
      normal = [dataTriNormal[n0], dataTriNormal[n1], dataTriNormal[n2]];
    } else {
      normal = null;
    }
    if (dataVertColor != null) {
      color = [dataVertColor[v0], dataVertColor[v1], dataVertColor[v2]];
    } else if (dataTriColor != null) {
      n0 = indices[baseOffset0 + inputTriColor.offset];
      n1 = indices[baseOffset1 + inputTriColor.offset];
      n2 = indices[baseOffset2 + inputTriColor.offset];
      color = [dataTriColor[n0], dataTriColor[n1], dataTriColor[n2]];
    } else {
      color = null;
    }
    face = new THREE.Face3(v0, v1, v2, normal, color);
    if (materialIndex != null) {
      face.materialIndex = materialIndex;
    }
    threejsGeometry.faces.push(face);
    for (i = _n = 0, _len4 = dataVertTexcoord.length; _n < _len4; i = ++_n) {
      data = dataVertTexcoord[i];
      if (data == null) {
        threejsGeometry.faceVertexUvs[i].push('abv');
        threejsGeometry.faceVertexUvs[i].push([new THREE.Vector2(0, 0), new THREE.Vector2(0, 0), new THREE.Vector2(0, 0)]);
      } else {
        texcoord = [data[v0], data[v1], data[v2]];
        threejsGeometry.faceVertexUvs[i].push(texcoord);
      }
    }
    for (i = _o = 0, _len5 = dataTriTexcoord.length; _o < _len5; i = ++_o) {
      data = dataTriTexcoord[i];
      if (data == null) {
        threejsGeometry.faceVertexUvs[i].push([new THREE.Vector2(0, 0), new THREE.Vector2(0, 0), new THREE.Vector2(0, 0)]);
      } else {
        t0 = indices[baseOffset0 + inputTriTexcoord[i].offset];
        t1 = indices[baseOffset1 + inputTriTexcoord[i].offset];
        t2 = indices[baseOffset2 + inputTriTexcoord[i].offset];
        texcoord = [data[t0], data[t1], data[t2]];
        threejsGeometry.faceVertexUvs[i].push(texcoord);
      }
    }
  }
};

/**
*   Adds zero UVs to an existing array of UVs
*
*   @param {!Array.<!THREE.Vector2>} faceVertexUvs
*   @param {!number} count
*/


ColladaLoader2.File.prototype._addEmptyUVs = function(faceVertexUvs, count) {
  var i, _i, _ref;

  for (i = _i = 0, _ref = count - 1; _i <= _ref; i = _i += 1) {
    faceVertexUvs.push(new THREE.Vector2(0, 0));
  }
};

/**
*   Creates an array of 3D vectors
*
*   @param {?ColladaLoader2.Source} source
*   @return {?Array.<!THREE.Vector3>}
*/


ColladaLoader2.File.prototype._createVector3Array = function(source) {
  var data, i, i0, i1, srcData, _i;

  if (source == null) {
    return null;
  }
  if (source.stride !== 3) {
    ColladaLoader2._log("Vector source data does not contain 3D vectors", ColladaLoader2.messageError);
    return null;
  }
  data = [];
  srcData = source.data;
  i0 = source.offset;
  i1 = source.offset + source.count * source.stride;
  if (i1 > source.data.length) {
    ColladaLoader2._log("Vector source tries to access too many elements", ColladaLoader2.messageError);
    return null;
  }
  for (i = _i = i0; _i <= i1; i = _i += 3) {
    data.push(new THREE.Vector3(srcData[i], srcData[i + 1], srcData[i + 2]));
  }
  return data;
};

/**
*   Creates an array of color vectors
*
*   @param {?ColladaLoader2.Source} source
*   @return {?Array.<!THREE.Color>}
*/


ColladaLoader2.File.prototype._createColorArray = function(source) {
  var data, i, i0, i1, srcData, _i, _ref;

  if (source == null) {
    return null;
  }
  if (source.stride < 3) {
    ColladaLoader2._log("Color source data does not contain 3D vectors", ColladaLoader2.messageError);
    return null;
  }
  data = [];
  srcData = source.data;
  i0 = source.offset;
  i1 = source.offset + source.count * source.stride;
  if (i1 > source.data.length) {
    ColladaLoader2._log("Color source tries to access too many elements", ColladaLoader2.messageError);
    return null;
  }
  for (i = _i = i0, _ref = source.stride; _ref > 0 ? _i <= i1 : _i >= i1; i = _i += _ref) {
    data.push(new THREE.Color().setRGB(srcData[i], srcData[i + 1], srcData[i + 2]));
  }
  return data;
};

/**
*   Creates an array of UV vectors
*
*   @param {?ColladaLoader2.Source} source
*   @return {?Array.<!THREE.Vector2>}
*/


ColladaLoader2.File.prototype._createUVArray = function(source) {
  var data, i, i0, i1, srcData, _i, _ref;

  if (source == null) {
    return null;
  }
  if (source.stride < 2) {
    ColladaLoader2._log("UV source data does not contain 2D vectors", ColladaLoader2.messageError);
    return null;
  }
  data = [];
  srcData = source.data;
  i0 = source.offset;
  i1 = source.offset + source.count * source.stride;
  if (i1 > source.data.length) {
    ColladaLoader2._log("UV source tries to access too many elements", ColladaLoader2.messageError);
    return null;
  }
  for (i = _i = i0, _ref = source.stride; _ref > 0 ? _i <= i1 : _i >= i1; i = _i += _ref) {
    data.push(new THREE.Vector2(srcData[i], 1.0 - srcData[i + 1]));
  }
  return data;
};

/**
*   Creates a map of three.js materials
*
*   @param {!Array.<!ColladaLoader2.InstanceMaterial>} daeInstanceMaterials
*   @return {!ColladaLoader2.ThreejsMaterialMap}
*/


ColladaLoader2.File.prototype._createMaterials = function(daeInstanceMaterials) {
  var daeInstanceMaterial, numMaterials, result, symbol, threejsMaterial, _i, _len;

  result = new ColladaLoader2.ThreejsMaterialMap;
  numMaterials = 0;
  for (_i = 0, _len = daeInstanceMaterials.length; _i < _len; _i++) {
    daeInstanceMaterial = daeInstanceMaterials[_i];
    symbol = daeInstanceMaterial.symbol;
    if (symbol == null) {
      ColladaLoader2._log("Material instance has no symbol, material skipped.", ColladaLoader2.messageError);
      continue;
    }
    if (result.indices[symbol] != null) {
      ColladaLoader2._log("Geometry instance tried to map material symbol " + symbol + " multiple times", ColladaLoader2.messageError);
      continue;
    }
    threejsMaterial = this._createMaterial(daeInstanceMaterial);
    if ((threejsMaterial.bumpMap != null) || (threejsMaterial.normalMap != null)) {
      result.needTangents = true;
    }
    this.threejs.materials.push(threejsMaterial);
    result.materials.push(threejsMaterial);
    result.indices[symbol] = numMaterials++;
  }
  return result;
};

/**
*   Creates a three.js material
*
*   @param {!ColladaLoader2.InstanceMaterial} daeInstanceMaterial
*   @return {!THREE.Material}
*/


ColladaLoader2.File.prototype._createMaterial = function(daeInstanceMaterial) {
  var daeEffect, daeMaterial;

  daeMaterial = ColladaLoader2.Material.fromLink(daeInstanceMaterial.material);
  if (daeMaterial == null) {
    ColladaLoader2._log("Material not found, using default material", ColladaLoader2.messageWarning);
    return this._createDefaultMaterial();
  }
  daeEffect = ColladaLoader2.Effect.fromLink(daeMaterial.effect);
  if (daeEffect == null) {
    ColladaLoader2._log("Material effect not found, using default material", ColladaLoader2.messageWarning);
    return this._createDefaultMaterial();
  }
  return this._createBuiltInMaterial(daeEffect);
};

/**
*   Creates a three.js shader material
*
*   @param {!ColladaLoader2.Effect} daeEffect
*   @return {!THREE.ShaderMaterial}
*/


ColladaLoader2.File.prototype._createShaderMaterial = function(daeEffect) {
  var materialNormalMap, shader, technique, textureDiffuse, textureLight, textureNormal, textureSpecular, uniforms;

  technique = daeEffect.technique;
  shader = THREE.ShaderUtils.lib["normal"];
  uniforms = THREE.UniformsUtils.clone(shader.uniforms);
  textureNormal = this._loadThreejsTexture(technique.bump);
  if (textureNormal != null) {
    uniforms["tNormal"].texture = textureNormal;
    uniforms["uNormalScale"].value = 0.85;
  }
  textureDiffuse = this._loadThreejsTexture(technique.diffuse);
  if (textureDiffuse != null) {
    uniforms["tDiffuse"].texture = textureDiffuse;
    uniforms["enableDiffuse"].value = true;
  } else {
    uniforms["enableDiffuse"].value = false;
  }
  textureSpecular = this._loadThreejsTexture(technique.specular);
  if (textureSpecular != null) {
    uniforms["tSpecular"].texture = textureSpecular;
    uniforms["enableSpecular"].value = true;
  } else {
    uniforms["enableSpecular"].value = false;
  }
  textureLight = this._loadThreejsTexture(technique.emission);
  if (textureLight != null) {
    uniforms["tAO"].texture = textureLight;
    uniforms["enableAO"].value = true;
  } else {
    uniforms["enableAO"].value = false;
  }
  this._setUniformColor(uniforms, "uDiffuseColor", technique.diffuse);
  this._setUniformColor(uniforms, "uSpecularColor", technique.specular);
  this._setUniformColor(uniforms, "uAmbientColor", technique.ambient);
  if (technique.shininess != null) {
    uniforms["uShininess"].value = technique.shininess;
  }
  if (this._hasTransparency(daeEffect)) {
    uniforms["uOpacity"].value = this._getOpacity(daeEffect);
  }
  materialNormalMap = new THREE.ShaderMaterial({
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: uniforms,
    lights: true
  });
  return materialNormalMap;
};

/**
*   Sets the value of a uniform color
*
*   @param {!Object.<!string, Object>} uniformMap
*   @param {!string} uniformName
*   @param {?ColladaLoader2.ColorOrTexture} color
*/


ColladaLoader2.File.prototype._setUniformColor = function(uniformMap, uniformName, color) {
  if ((color != null) && (color.color != null)) {
    uniformMap[uniformName].value.setHex(ColladaLoader2._colorToHex(color.color));
  }
};

/**
*   Returns the surface opacity of an effect
*   Opacity of 1.0 means the object is fully opaque
*   Opacity of 0.0 means the object is fully transparent
*   See section "Determining Transparency (Opacity)" in the COLLADA spec
*
*   @param {!ColladaLoader2.Effect} daeEffect
*   @return {!number}
*/


ColladaLoader2.File.prototype._getOpacity = function(daeEffect) {
  var opacityMode, technique, transparency, transparent, transparentA, _ref;

  technique = daeEffect.technique;
  transparent = technique.transparent;
  opacityMode = transparent != null ? transparent.opaque : void 0;
  if ((opacityMode != null) && opacityMode !== "A_ONE") {
    ColladaLoader2._log("Opacity mode " + opacityMode + " not supported, transparency will be broken", ColladaLoader2.messageWarning);
  }
  if ((transparent != null ? transparent.textureSampler : void 0) != null) {
    ColladaLoader2._log("Separate transparency texture not supported, transparency will be broken", ColladaLoader2.messageWarning);
  }
  transparentA = (transparent != null ? (_ref = transparent.color) != null ? _ref[3] : void 0 : void 0) || 1;
  transparency = technique.transparency || 1;
  return transparentA * transparency;
};

/**
*   Returns true if the effect has any transparency information
*
*   @param {!ColladaLoader2.Effect} daeEffect
*   @return {!boolean}
*/


ColladaLoader2.File.prototype._hasTransparency = function(daeEffect) {
  var technique, transparency, transparent;

  technique = daeEffect.technique;
  transparent = technique.transparent;
  transparency = technique.transparency;
  return ((transparent != null ? transparent.textureSampler : void 0) != null) || ((transparency != null) && transparency !== 1);
};

/**
*   Returns true if the effect requests double-sided rendering
*
*   @param {!ColladaLoader2.Effect} daeEffect
*   @return {!boolean}
*/


ColladaLoader2.File.prototype._isDoubleSided = function(daeEffect) {
  var double_sided, technique;

  technique = daeEffect.technique;
  if (technique.double_sided != null) {
    return technique.double_sided;
  }
  double_sided = this._getDoubleSidedParam(daeEffect.params);
  if (double_sided != null) {
    return double_sided;
  }
  double_sided = this._getDoubleSidedParam(daeEffect.technique.params);
  if (double_sided != null) {
    return double_sided;
  }
  return false;
};

/**
*   Returns the value of the param with the DOUBLE_SIDED semantic
*
*   @param {!Array.<!ColladaLoader2.EffectParam>} params
*   @return {?boolean}
*/


ColladaLoader2.File.prototype._getDoubleSidedParam = function(params) {
  var param, _i, _len;

  for (_i = 0, _len = params.length; _i < _len; _i++) {
    param = params[_i];
    if (param.semantic === "DOUBLE_SIDED") {
      if (param.floats != null) {
        return param.floats[0] > 0;
      } else {
        ColladaLoader2._log("Missing value for DOUBLE_SIDED parameter, assuming 'true'", ColladaLoader2.messageWarning);
        return true;
      }
    }
  }
  return null;
};

/**
*   Creates a three.js built-in material
*
*   @param {!ColladaLoader2.Effect} daeEffect
*   @return {!THREE.Material}
*/


ColladaLoader2.File.prototype._createBuiltInMaterial = function(daeEffect) {
  var hasTransparency, opacity, params, technique;

  technique = daeEffect.technique;
  params = {};
  this._setThreejsMaterialColor(params, technique.diffuse, "diffuse", "map", false);
  this._setThreejsMaterialColor(params, technique.emission, "emissive", null, false);
  this._setThreejsMaterialColor(params, technique.ambient, "ambient", "lightMap", false);
  this._setThreejsMaterialColor(params, technique.specular, "specular", "specularMap", false);
  this._setThreejsMaterialColor(params, technique.bump, null, "normalMap", false);
  if (params["bumpMap"]) {
    params["bumpScale"] = 1.0;
  }
  if (params["normalMap"]) {
    params["normalScale"] = new THREE.Vector2(1.0, 1.0);
  }
  if (params["map"] != null) {
    params["diffuse"] = 0xffffff;
  }
  if (params["specularMap"] != null) {
    params["specular"] = 0xffffff;
  }
  if (params["diffuse"] == null) {
    params["diffuse"] = 0xffffff;
  }
  if (technique.shininess != null) {
    params["shininess"] = technique.shininess;
  }
  if (technique.reflectivity != null) {
    params["reflectivity"] = technique.reflectivity;
  }
  hasTransparency = this._hasTransparency(daeEffect);
  if (hasTransparency) {
    params["transparent"] = true;
    opacity = this._getOpacity(daeEffect);
    params["opacity"] = opacity;
    params["alphaTest"] = 0.001;
  }
  if (this._isDoubleSided(daeEffect)) {
    params["side"] = THREE.DoubleSide;
  }
  params["shading"] = THREE.SmoothShading;
  params["perPixel"] = true;
  switch (technique.shading) {
    case "blinn":
    case "phong":
      params["color"] = params["diffuse"];
      return new THREE.MeshPhongMaterial(params);
    case "lambert":
      params["color"] = params["diffuse"];
      return new THREE.MeshLambertMaterial(params);
    case "constant":
      params["color"] = params["emission"];
      return new THREE.MeshBasicMaterial(params);
    default:
      return this._createDefaultMaterial();
  }
};

/**
*   Creates a default three.js material
*
*   This is used if the material definition is somehow invalid
*   @return {!THREE.Material}
*/


ColladaLoader2.File.prototype._createDefaultMaterial = function() {
  return new THREE.MeshLambertMaterial({
    color: 0xdddddd,
    shading: THREE.FlatShading
  });
};

/**
*   Sets a three.js material parameter
*
*   @param {!Object} params
*   @param {?ColladaLoader2.ColorOrTexture} colorOrTexture
*   @param {?string} nameColor
*   @param {?string} nameTexture
*   @param {!boolean} replace
*/


ColladaLoader2.File.prototype._setThreejsMaterialColor = function(params, colorOrTexture, nameColor, nameTexture, replace) {
  var threejsTexture;

  if (colorOrTexture == null) {
    return;
  }
  if ((colorOrTexture.color != null) && (nameColor != null)) {
    if (!replace && (params[nameColor] != null)) {
      return;
    }
    params[nameColor] = ColladaLoader2._colorToHex(colorOrTexture.color);
  } else if ((colorOrTexture.textureSampler != null) && (nameTexture != null)) {
    if (!replace && (params[nameTexture] != null)) {
      return;
    }
    threejsTexture = this._loadThreejsTexture(colorOrTexture);
    if (threejsTexture != null) {
      params[nameTexture] = threejsTexture;
    }
  }
};

/**
*   Loads a three.js texture
*
*   @param {ColladaLoader2.ColorOrTexture} colorOrTexture
*   @return {THREE.Texture|null}
*/


ColladaLoader2.File.prototype._loadThreejsTexture = function(colorOrTexture) {
  var imageURL, texture, textureImage, textureSampler, textureSurface;

  if (colorOrTexture.textureSampler == null) {
    return null;
  }
  textureSampler = ColladaLoader2.EffectParam.fromLink(colorOrTexture.textureSampler);
  if (textureSampler == null) {
    ColladaLoader2._log("Texture sampler not found, texture will be missing", ColladaLoader2.messageWarning);
    return null;
  }
  textureSampler = textureSampler.sampler;
  if (textureSampler == null) {
    ColladaLoader2._log("Texture sampler param has no sampler, texture will be missing", ColladaLoader2.messageWarning);
    return null;
  }
  textureImage = null;
  if (textureSampler.image != null) {
    textureImage = ColladaLoader2.Image.fromLink(textureSampler.image);
    if (textureImage == null) {
      ColladaLoader2._log("Texture image not found, texture will be missing", ColladaLoader2.messageWarning);
      return null;
    }
  } else if (textureSampler.surface != null) {
    textureSurface = ColladaLoader2.EffectParam.fromLink(textureSampler.surface);
    if (textureSurface == null) {
      ColladaLoader2._log("Texture surface not found, texture will be missing", ColladaLoader2.messageWarning);
      return null;
    }
    textureSurface = textureSurface.surface;
    if (textureSurface == null) {
      ColladaLoader2._log("Texture surface param has no surface, texture will be missing", ColladaLoader2.messageWarning);
      return null;
    }
    textureImage = ColladaLoader2.Image.fromLink(textureSurface.initFrom);
    if (textureImage == null) {
      ColladaLoader2._log("Texture image not found, texture will be missing", ColladaLoader2.messageWarning);
      return null;
    }
  }
  if (textureImage.initFrom == null) {
    ColladaLoader2._log("Texture image has no source url, texture will be missing", ColladaLoader2.messageWarning);
    return null;
  }
  imageURL = this._baseUrl + textureImage.initFrom;
  texture = this._loader._loadTextureFromURL(imageURL);
  return texture;
};

/**
*   Texture cache
*
*   @type {!Object.<!string, !THREE.Texture>}
*   @private
*/


ColladaLoader2.prototype._imageCache;

/**
*   Loader options
*
*   @type {!Object}
*   @expose
*/


ColladaLoader2.prototype.options;

/**
*   Initializes the loader
*
*   @private
*/


ColladaLoader2.prototype._init = function() {
  this._imageCache = {};
  return this.options = {
    "useAnimations": true,
    "convertSkinsToMorphs": false,
    "verboseMessages": false,
    "localImageMode": false
  };
};

/**
*   Sets a new callback for log messages.
*   This is just an alias for ColladaLoader2.setLog().
*
*   @param {?function(string, number)} logCallback
*   @expose
*/


ColladaLoader2.prototype.setLog = function(logCallback) {
  return ColladaLoader2.setLog(logCallback);
};

/**
*   Adds images to the texture cache
*
*   @param {Array.<!THREE.Texture>} textures
*   @expose
*/


ColladaLoader2.prototype.addCachedTextures = function(textures) {
  var key, value;

  for (key in textures) {
    value = textures[key];
    this._imageCache[key] = value;
  }
};

/**
*   Loads a collada file from a URL.
*
*   @param {!string} url
*   @param {?function(ColladaLoader2.File)} readyCallback
*   @param {?function(Object)} progressCallback
*   @expose
*/


ColladaLoader2.prototype.load = function(url, readyCallback, progressCallback) {
  var length, req, _ref,
    _this = this;

  length = 0;
  if ((_ref = document.implementation) != null ? _ref.createDocument : void 0) {
    req = new XMLHttpRequest();
    if (typeof req.overrideMimeType === "function") {
      req.overrideMimeType("text/xml");
    }
    req.onreadystatechange = function() {
      if (req.readyState === 4) {
        if (req.status === 0 || req.status === 200) {
          if (req.responseXML) {
            return _this.parse(req.responseXML, readyCallback, url);
          } else {
            return ColladaLoader2._log("Empty or non-existing file " + url + ".", ColladaLoader2.messageError);
          }
        }
      } else if (req.readyState === 3) {
        if (progressCallback) {
          if (length === 0) {
            length = req.getResponseHeader("Content-Length");
          }
          return progressCallback({
            total: length,
            loaded: req.responseText.length
          });
        }
      }
    };
    req.open("GET", url, true);
    req.send(null);
  } else {
    ColladaLoader2._log("Don't know how to parse XML!", ColladaLoader2.messageError);
  }
};

/**
*   Parses a COLLADA XML document.
*
*   @param {!XMLDocument} doc
*   @param {?function(ColladaLoader2.File)} readyCallback
*   @param {!string} url
*   @return {ColladaLoader2.File}
*   @expose
*/


ColladaLoader2.prototype.parse = function(doc, readyCallback, url) {
  var file;

  file = new ColladaLoader2.File(this);
  file.setUrl(url);
  file._readyCallback = readyCallback;
  file._parseXml(doc);
  file._linkAnimations();
  file._createSceneGraph();
  if (file._readyCallback) {
    file._readyCallback(file);
  }
  return file;
};

/**
*   Loads a three.js texture from a URL
*
*   @param {!string} imageURL
*   @return {!THREE.Texture}
*   @private
*/


ColladaLoader2.prototype._loadTextureFromURL = function(imageURL) {
  var texture;

  texture = this._imageCache[imageURL];
  if (texture != null) {
    return texture;
  }
  if (this.options.localImageMode) {
    texture = this._loadImageLocal(imageURL);
  }
  if (texture == null) {
    texture = this._loadImageSimple(imageURL);
  }
  if (texture != null) {
    this._imageCache[imageURL] = texture;
  } else {
    ColladaLoader2._log("Texture " + imageURL + " could not be loaded, texture will be ignored.", ColladaLoader2.messageError);
  }
  return texture;
};

/**
*   Loads an image using a the threejs image loader
*
*   @param {!string} imageURL
*   @return {!THREE.Texture}
*   @private
*/


ColladaLoader2.prototype._loadImageThreejs = function(imageURL) {
  var texture;

  texture = THREE.ImageUtils.loadTexture(imageURL);
  texture.flipY = false;
  return texture;
};

/**
*   Loads an image using a very simple approach
*
*   @param {!string} imageURL
*   @return {!THREE.Texture}
*   @private
*/


ColladaLoader2.prototype._loadImageSimple = function(imageURL) {
  var image, texture;

  image = new Image();
  texture = new THREE.Texture(image);
  texture.flipY = false;
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  image.onload = function() {
    return texture.needsUpdate = true;
  };
  image.crossOrigin = 'anonymous';
  image.src = imageURL;
  return texture;
};

/**
*   Loads an image from the cache, trying different variations of the file name
*
*   @param {!string} imageURL
*   @return {?THREE.Texture}
*   @private
*/


ColladaLoader2.prototype._loadImageLocal = function(imageURL) {
  var cachedURLBase, imageURLBase, key, texture, value, _ref, _ref1;

  texture = null;
  imageURLBase = this._removeSameDirectoryPath(imageURL);
  _ref = this._imageCache;
  for (key in _ref) {
    value = _ref[key];
    cachedURLBase = this._removeSameDirectoryPath(key);
    if (imageURLBase.indexOf(cachedURLBase) >= 0) {
      texture = value;
      break;
    }
  }
  imageURLBase = this._removeSameDirectoryPath(this._removeFileExtension(imageURL));
  if (texture == null) {
    _ref1 = this._imageCache;
    for (key in _ref1) {
      value = _ref1[key];
      cachedURLBase = this._removeSameDirectoryPath(this._removeFileExtension(key));
      if (imageURLBase.indexOf(cachedURLBase) >= 0) {
        texture = value;
        break;
      }
    }
  }
  return texture;
};

/**
*   Removes the file extension from a string
*
*   @param {!string} filePath
*   @return {!string}
*   @private
*/


ColladaLoader2.prototype._removeFileExtension = function(filePath) {
  return filePath.substr(0, filePath.lastIndexOf(".")) || filePath;
};

/**
*   Removes the the pattern "./" from a string
*
*   @param {!string} filePath
*   @return {!string}
*   @private
*/


ColladaLoader2.prototype._removeSameDirectoryPath = function(filePath) {
  return filePath.replace(/^.\//, "");
};

/**
*   @const
*   @type {!number}
*   @expose
*/


ColladaLoader2.messageTrace = 0;

/**
*   @const
*   @type {!number}
*   @expose
*/


ColladaLoader2.messageInfo = 1;

/**
*   @const
*   @type {!number}
*   @expose
*/


ColladaLoader2.messageWarning = 2;

/**
*   @const
*   @type {!number}
*   @expose
*/


ColladaLoader2.messageError = 3;

/**
*   @const
*   @type {!Array.<!string>}
*   @expose
*/


ColladaLoader2.messageTypes = ["TRACE", "INFO", "WARNING", "ERROR"];

/**
*   Sets a new callback for log messages.
*
*   @param {?function(string, number)} logCallback
*   @expose
*/


ColladaLoader2.setLog = function(logCallback) {
  ColladaLoader2._log = logCallback || ColladaLoader2._colladaLogConsole;
};

/**
*   Default log message callback.
*
*   @param {!string} msg
*   @param {!number} type
*   @private
*/


ColladaLoader2._colladaLogConsole = function(msg, type) {
  console.log("ColladaLoader2 " + ColladaLoader2.messageTypes[type] + ": " + msg);
};

/**
*   Global log output function pointer
*
*   @type{!function(string, number)}
*   @private
*/


ColladaLoader2._log = ColladaLoader2._colladaLogConsole;

/**
*   Report an unexpected child element
*
*   @param {!Node} child
*   @private
*/


ColladaLoader2._reportUnexpectedChild = function(child) {
  ColladaLoader2._log("Skipped unknown element " + (ColladaLoader2._getNodePath(child)) + ".", ColladaLoader2.messageWarning);
};

/**
*   Report an unhandled extra element
*
*   @param {!Node} child
*   @private
*/


ColladaLoader2._reportUnhandledExtra = function(child) {
  ColladaLoader2._log("Skipped element " + (ColladaLoader2._getNodePath(child)) + ". Element is legal, but not handled by this loader.", ColladaLoader2.messageWarning);
};

/**
*   Report an unhandled extra element
*
*   @param {!ColladaLoader2.UrlLink|!ColladaLoader2.FxLink|!ColladaLoader2.SidLink} link
*   @param {!function(...)} type
*   @private
*/


ColladaLoader2._reportInvalidTargetType = function(link, type) {
  ColladaLoader2._log("Link " + link.url + " does not point to a " + type.name, ColladaLoader2.messageError);
};

/**
*   Returns the path of a XML node
*
*   @param {!Node} node
*   @return {!string}
*   @private
*/


ColladaLoader2._getNodePath = function(node) {
  var len, maxLen, path;

  path = "<" + node.nodeName + ">";
  len = 1;
  maxLen = 10;
  while (node.parentNode != null) {
    node = node.parentNode;
    if (node.nodeName.toUpperCase() === "COLLADA") {
      break;
    } else if (len >= maxLen) {
      path = ".../" + path;
      break;
    } else {
      path = ("<" + node.nodeName + ">/") + path;
      len += 1;
    }
  }
  return path;
};

/**
*   Splits a string into whitespace-separated strings
*
*   @param {!string} str
*   @return {!Array.<!string>}
*   @private
*/


ColladaLoader2._strToStrings = function(str) {
  var trimmed;

  if (str.length > 0) {
    trimmed = str.trim();
    return trimmed.split(/\s+/);
  } else {
    return [];
  }
};

/**
*   Parses a string of whitespace-separated float numbers
*
*   A very minor speedup could be achieved by iterating over characters of the string
*   and parsing substrings on the fly.
*   Using Float32Array does not seem to give any speedup, but could save memory.
*
*   @param {!string} str
*   @return {!Float32Array}
*   @private
*/


ColladaLoader2._strToFloats = function(str) {
  var data, i, string, strings, _i, _len;

  strings = ColladaLoader2._strToStrings(str);
  data = new Float32Array(strings.length);
  for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
    string = strings[i];
    data[i] = parseFloat(string);
  }
  return data;
};

/**
*   Parses a string of whitespace-separated int numbers
*
*   @param {!string} str
*   @return {!Int32Array}
*   @private
*/


ColladaLoader2._strToInts = function(str) {
  var data, i, string, strings, _i, _len;

  strings = ColladaLoader2._strToStrings(str);
  data = new Int32Array(strings.length);
  for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
    string = strings[i];
    data[i] = parseInt(string, 10);
  }
  return data;
};

/**
*   Parses a string of whitespace-separated boolean values
*
*   @param {!string} str
*   @return {!Uint8Array}
*   @private
*/


ColladaLoader2._strToBools = function(str) {
  var data, i, string, strings, _i, _len, _ref;

  strings = ColladaLoader2._strToStrings(str);
  data = new Uint8Array(strings.length);
  for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
    string = strings[i];
    data[i] = (_ref = string === "true" || string === "1") != null ? _ref : {
      1: 0
    };
  }
  return data;
};

/**
*   Parses a string (consisting of four floats) into a RGBA color
*
*   @param {!string} str
*   @return {?Float32Array}
*   @private
*/


ColladaLoader2._strToColor = function(str) {
  var rgba;

  rgba = ColladaLoader2._strToFloats(str);
  if (rgba.length === 4) {
    return rgba;
  } else {
    return null;
  }
};

/**
*   Converts a 4D array to a hex number
*
*   @param {!Array.<!number>|!Float32Array} rgba
*   @return {!number}
*   @private
*/


ColladaLoader2._colorToHex = function(rgba) {
  return Math.floor(rgba[0] * 255) << 16 ^ Math.floor(rgba[1] * 255) << 8 ^ Math.floor(rgba[2] * 255);
};

/**
*   Converts an array of floats to a 4D matrix
*
*   @param {!Array.<!number>|!Float32Array} data
*   @param {!number} offset
*   @return {!THREE.Matrix4}
*   @private
*/


ColladaLoader2._floatsToMatrix4ColumnMajor = function(data, offset) {
  return new THREE.Matrix4(data[0 + offset], data[4 + offset], data[8 + offset], data[12 + offset], data[1 + offset], data[5 + offset], data[9 + offset], data[13 + offset], data[2 + offset], data[6 + offset], data[10 + offset], data[14 + offset], data[3 + offset], data[7 + offset], data[11 + offset], data[15 + offset]);
};

/**
*   Converts an array of floats to a 4D matrix
*
*   @param {!Array.<!number>|!Float32Array} data
*   @param {!number} offset
*   @return {!THREE.Matrix4}
*   @private
*/


ColladaLoader2._floatsToMatrix4RowMajor = function(data, offset) {
  return new THREE.Matrix4(data[0 + offset], data[1 + offset], data[2 + offset], data[3 + offset], data[4 + offset], data[5 + offset], data[6 + offset], data[7 + offset], data[8 + offset], data[9 + offset], data[10 + offset], data[11 + offset], data[12 + offset], data[13 + offset], data[14 + offset], data[15 + offset]);
};

/**
*   Copies an array of floats to a 4D matrix (row major order)
*
*   Note: THREE.Matrix4 has a constructor that takes elements in column-major order.
*   Since this function takes elements in column-major order as well, they are passed in order.
*
*   @param {!Array.<!number>|!Float32Array} data
*   @param {!number} offset
*   @param {!THREE.Matrix4} matrix
*   @private
*/


ColladaLoader2._fillMatrix4ColumnMajor = function(data, offset, matrix) {
  matrix.set(data[0 + offset], data[4 + offset], data[8 + offset], data[12 + offset], data[1 + offset], data[5 + offset], data[9 + offset], data[13 + offset], data[2 + offset], data[6 + offset], data[10 + offset], data[14 + offset], data[3 + offset], data[7 + offset], data[11 + offset], data[15 + offset]);
};

/**
*   Copies an array of floats to a 4D matrix
*
*   Note: THREE.Matrix4 has a constructor that takes elements in column-major order.
*   Since this function takes elements in row-major order, they are swizzled.
*
*   @param {!Array.<!number>|!Float32Array} data
*   @param {!number} offset
*   @param {!THREE.Matrix4} matrix
*   @private
*/


ColladaLoader2._fillMatrix4RowMajor = function(data, offset, matrix) {
  matrix.set(data[0 + offset], data[1 + offset], data[2 + offset], data[3 + offset], data[4 + offset], data[5 + offset], data[6 + offset], data[7 + offset], data[8 + offset], data[9 + offset], data[10 + offset], data[11 + offset], data[12 + offset], data[13 + offset], data[14 + offset], data[15 + offset]);
};

/**
*   Checks the matrix
*
*   @param {!THREE.Matrix4} matrix
*   @private
*/


ColladaLoader2._checkMatrix4 = function(matrix) {
  var col1len, col2len, col3len, me;

  me = matrix.elements;
  if (me[3] !== 0 || me[7] !== 0 || me[11] !== 0 || me[15] !== 1) {
    throw new Error("Last row isnt [0,0,0,1]");
  }
  col1len = Math.sqrt(me[0] * me[0] + me[1] * me[1] + me[2] * me[2]);
  col2len = Math.sqrt(me[4] * me[4] + me[5] * me[5] + me[6] * me[6]);
  col3len = Math.sqrt(me[8] * me[8] + me[9] * me[9] + me[10] * me[10]);
  if (col1len < 0.9 || col1len > 1.1) {
    throw new Error("First column has significant scaling");
  }
  if (col2len < 0.9 || col2len > 1.1) {
    throw new Error("Second column has significant scaling");
  }
  if (col3len < 0.9 || col3len > 1.1) {
    throw new Error("Third column has significant scaling");
  }
};

/**
*    Converts an array of floats to a 3D vector
*
*   @param {!Array.<!number>|!Float32Array} data
*   @return {!THREE.Vector3}
*   @private
*/


ColladaLoader2._floatsToVec3 = function(data) {
  return new THREE.Vector3(data[0], data[1], data[2]);
};

/**
*   Conversion factor from degrees to radians
*
*   @const
*   @type {!number}
*   @private
*/


ColladaLoader2.TO_RADIANS = Math.PI / 180.0;

if (typeof module !== "undefined" && module !== null) {
  module['exports'] = ColladaLoader2;
} else if (typeof window !== "undefined" && window !== null) {
  window['ColladaLoader2'] = ColladaLoader2;
}

/*
//@ sourceMappingURL=ColladaLoader2.map
*/
